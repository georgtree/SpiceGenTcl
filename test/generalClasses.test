#  .|'''.|            ||                   ..|'''.|                   |''||''|         '||'
#  ||..  '  ... ...  ...    ....    ....  .|'     '    ....  .. ...      ||      ....   ||  
#   ''|||.   ||'  ||  ||  .|   '' .|...|| ||    .... .|...||  ||  ||     ||    .|   ''  ||  
# .     '||  ||    |  ||  ||      ||      '|.    ||  ||       ||  ||     ||    ||       ||  
# |'....|'   ||...'  .||.  '|...'  '|...'  ''|...'|   '|...' .||. ||.   .||.    '|...' .||. 
#            ||                                                                             
#           ''''                                                                            
# generalClasses.test
# Tests Ngspice simulators classes
#
# Copyright (c) 2024 George Yashin, georgtree@gmail.com
#
# MIT License
# See the file "LICENSE.txt" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

package require tcltest
namespace import ::tcltest::*
package require SpiceGenTcl
namespace import ::SpiceGenTcl::*
set currentDir [file normalize [file dirname [info script]]]
source [file join $currentDir testUtilities.tcl]
importNgspice


###  SPICEElement class tests 

test testPinClass-1 {test creation of Pin class instance and getName interface} -setup {
    oo::configurable create DummyClass {
        superclass ::SpiceGenTcl::SPICEElement
    }
    set inst [DummyClass new]
} -body {
    catch {$inst genSPICEString} errorStr
    return $errorStr
} -result {Not implemented} -cleanup {
    unset inst errorStr
    DummyClass destroy
}

###  Pin class tests 

test testPinClass-1 {test creation of Pin class instance and getName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    set result [$pinInst configure -name]
} -result drain -cleanup {
    unset pinInst result
}

test testPinClass-2 {test creation of Pin class instance and getName interface} -setup {
    set pinInst [Pin new 23 netd]
} -body {
    set result [$pinInst configure -name]
} -result 23 -cleanup {
    unset pinInst result
}

test testPinClass-3 {test creation of Pin class instance and getNodeName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    set result [$pinInst configure -node]
} -result netd -cleanup {
    unset pinInst result
}

test testPinClass-4 {test creation of Pin class instance and genSPICEStr interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    set result [$pinInst genSPICEString]
} -result netd -cleanup {
    unset pinInst result
}

test testPinClass-5 {test creation of Pin class instance and checkFloating interface} -setup {
    set pinInst [Pin new drain {}]
} -body {
    set result [$pinInst checkFloating]
} -result true -cleanup {
    unset pinInst result
}

testTemplate testPinClass-6 {} {Pin new drain {}} {Pin 'drain' is not connected to the node so can't be netlisted}

test testPinClass-10 {test creation of Pin class instance and handling empty string in the name} -body {
    catch {set pinInst [Pin new "" netd]} errorStr
    return $errorStr
} -result {Pin must have a name, empty string was provided} -cleanup {
    unset errorStr
}

test testPinClass-11 {test creation of Pin class instance and setNodeName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    $pinInst configure -node net1
    set result [$pinInst configure -node]
} -result net1 -cleanup {
    unset pinInst result
}
    
test testPinClass-12 {test creation of Pin class instance and setNodeName interface with wrong node name} -setup {
    set pinInst [Pin new drain netd]
} -body {
    catch {$pinInst configure -node 123net} errorStr
    return $errorStr
} -result {Node name '123net' is not a valid name} -cleanup {
    unset pinInst errorStr
}
    
test testPinClass-13 {test creation of Pin class instance and unsetNodeName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    $pinInst unsetNodeName
    set result [$pinInst configure -node]
} -result {} -cleanup {
    unset pinInst result
}
    
test testPinClass-14 {test creation of Pin class instance and getName interface} -setup {
    set pinInst [Pin new drain_ netd_]
} -body {
    set result [$pinInst configure -name]
} -result drain_ -cleanup {
    unset pinInst result
}
    
###  Parameter class tests 

test testParameterClass-1 {test creation of Parameter class instance and getName interface} -setup {
    set parInst [Parameter new VTH 0.7]
} -body {
    set result [$parInst configure -name]
} -result vth -cleanup {
    unset parInst result
}

test testParameterClass-2 {test creation of Parameter class instance and getValue interface} -setup {
    set parInst [Parameter new VTH 0.7]
} -body {
    set result [$parInst configure -value]
} -result 0.7 -cleanup {
    unset parInst result
}

test testParameterClass-3 {test creation of Parameter class instance and getValue interface} -setup {
    set parInst [Parameter new VTH 0.007e+3]
} -body {
    set result [$parInst configure -value]
} -result 0.007e+3 -cleanup {
    unset parInst result
}

test testParameterClass-4 {test creation of Parameter class instance and handling wrong symbols in the name}  -body {
    catch {set parInst [Parameter new VT.H 0.7]} errorStr
    return $errorStr
} -result {Parameter name 'VT.H' is not a valid name} -cleanup {
    unset errorStr
}

test testParameterClass-5 {test creation of Parameter class instance and handling empty string in the name}  -body {
    catch {set parInst [Parameter new "" 0.7]} errorStr
    return $errorStr
} -result {Parameter must have a name, empty string was provided} -cleanup {
    unset errorStr
}

test testParameterClass-6 {test creation of Parameter class instance and handling wrong form of the value}  -body {
    catch {set parInst [Parameter new VTH 0.7e-]} errorStr
    return $errorStr
} -result {Value '0.7e-' is not a valid value} -cleanup {
    unset errorStr
}

test testParameterClass-7 {test creation of Parameter class instance and setValue interface} -setup {
    set parInst [Parameter new VTH 0.7]
    $parInst configure -value 1.0
} -body {
    set result [$parInst configure -value]
} -result 1.0 -cleanup {
    unset parInst result
}

test testParameterClass-8 {test creation of Parameter class instance and setValue interface with wrong value string} -setup {
    set parInst [Parameter new VTH 0.7]
} -body {
    catch {$parInst configure -value 1..0} errorStr
    return $errorStr
} -result {Value '1..0' is not a valid value} -cleanup {
    unset parInst errorStr
}

test testParameterClass-9 {test creation of Parameter class instance and getName interface} -setup {
    set parInst [Parameter new VTH 700u]
} -body {
    set result [$parInst configure -name]
} -result vth -cleanup {
    unset parInst result
}

test testParameterClass-10 {test creation of Parameter class instance and getName interface} -setup {
    set parInst [Parameter new VTH 700U]
} -body {
    set result [$parInst configure -name]
} -result vth -cleanup {
    unset parInst result
}

test testParameterClass-11 {test creation of Parameter class instance} -setup {
    set parInst [Parameter new GMIN 1.0T]
} -body {
    set result [$parInst configure -value]
} -result 1.0t -cleanup {
    unset parInst result
}

test testParameterClass-12 {test creation of Parameter class instance} -setup {
    set parInst [Parameter new GMIN 1.0meg]
} -body {
    set result [$parInst configure -value]
} -result 1.0meg -cleanup {
    unset parInst result
}

test testParameterClass-13 {test creation of Parameter class instance} -setup {
    set parInst [Parameter new GMIN 1e-6Meg]
} -body {
    set result [$parInst configure -value]
} -result 1e-6meg -cleanup {
    unset parInst result
}

test testParameterClass-14 {test creation of Parameter class instance and handling wrong form of the value}  -body {
    catch {set parInst [Parameter new VTH 70!0meg]} errorStr
    return $errorStr
} -result {Value '70!0meg' is not a valid value} -cleanup {
    unset errorStr
}

###  ParameterNode class tests 

testTemplate testParameterNodeClass-1 {} {ParameterNode new v(1) 0.7} {v(1)=0.7}

###  ParameterNodeEquation class tests 

testTemplate testParameterNodeEquationClass-1 {} {ParameterNodeEquation new v(1) volt} {v(1)={volt}}
testTemplate testParameterNodeEquationClass-2 {} {ParameterNodeEquation new v(1) {}}\
        {Parameter 'v(1)' equation can't be empty}

###  ParameterNoCheck class tests 

test testParameterNoCheckClass-1 {test creation of ParameterNoCheck class instance} -setup {
    set parInst [ParameterNoCheck new VTH 0.7]
} -body {
    $parInst configure -value 1..0
    return [$parInst configure -value]
} -result 1..0 -cleanup {
    unset parInst
}

testTemplate testParameterNoCheckClass-2 {} {ParameterNoCheck new VTH {}} {Value '' is not a valid value}
    
###  ParameterDefault class tests 

test testParameterDefaultClass-1 {test creation of ParameterDefault class instance and getName interface} -setup {
    set parInst [ParameterDefault new U0 100 200]
} -body {
    set result [$parInst configure -name]
} -result u0 -cleanup {
    unset parInst result
}

test testParameterDefaultClass-2 {test creation of ParameterDefault class instance and getValue interface} -setup {
    set parInst [ParameterDefault new U0 100 200]
} -body {
    set result [$parInst configure -value]
} -result 100 -cleanup {
    unset parInst result
}

test testParameterDefaultClass-3 {test creation of ParameterDefault class instance and getDefValue interface} -setup {
    set parInst [ParameterDefault new U0 100 200]
} -body {
    set result [$parInst configure -defvalue]
} -result 200 -cleanup {
    unset parInst result
}

test testParameterDefaultClass-4 {test creation of ParameterDefault class instance and resetValue method} -setup {
    set parInst [ParameterDefault new U0 100 200]
    $parInst resetValue
} -body {
    set result [$parInst configure -value]
} -result 200 -cleanup {
    unset parInst result
}
    
###  ParameterSwitch class tests  

testTemplate testParameterSwitchClass-1 {} {ParameterSwitch new U0} u0

###  ParameterVector class tests

testTemplate testParameterVectorClass-1 {} {ParameterVector new v(node)} v(node)
testTemplate testParameterVectorClass-2 {} {ParameterVector new i(vin)} i(vin)
testTemplate testParameterVectorClass-3 {} {ParameterVector new vsource#branch} vsource#branch
testTemplate testParameterVectorClass-4 {} {ParameterVector new {@m2[vdsat]}} {@m2[vdsat]}
testTemplate testParameterVectorClass-5 {} {ParameterVector new node} node

###  ParameterPositional class tests 

test testParameterPositionalClass-1 {test creation of ParameterPositional class instance and getName interface} -setup {
    set parInst [ParameterPositional new U0 100]
} -body {
    set result [$parInst configure -name]
} -result u0 -cleanup {
    unset parInst result
}

testTemplate testParameterPositionalClass-2 {} {ParameterPositional new U0 100} 100

###  ParameterPositionalNoCheck class tests 

test testParameterPositionalNoCheckClass-1 {test creation of ParameterPositionalNoCheck class instance} -setup {
    set parInst [ParameterPositionalNoCheck new U0 100]
} -body {
    $parInst configure -value 1...1
    set result [$parInst configure -value]
} -result 1...1 -cleanup {
    unset parInst result
}

testTemplate testParameterPositionalNoCheckClass-2 {} {ParameterPositionalNoCheck new U0 1...1} 1...1
testTemplate testParameterPositionalNoCheckClass-3 {} {ParameterPositionalNoCheck new U0 {}}\
        {Value '' is not a valid value}

###  ParameterEquation class tests 

test testParameterEquationClass-1 {test creation of ParameterEquation class instance and getValue interface} -setup {
    set parInst [ParameterEquation new U0T {temp*2.1+U0}]
} -body {
    set result [$parInst configure -value]
} -result temp*2.1+U0 -cleanup {
    unset parInst result
}

testTemplate testParameterEquationClass-2 {} {ParameterEquation new U0T {temp*2.1+U0}} u0t={temp*2.1+U0}
testTemplate testParameterEquationClass-3 {} {ParameterEquation new U0T {}} {Parameter 'u0t' equation can't be empty}

###  ParameterPositionalEquation class tests 

testTemplate testParameterPositionalEquationClass-1 {} {ParameterPositionalEquation new U0T {temp*2.1+U0}} {{temp*2.1+U0}}

###  Device class tests 

test testDeviceClass-1 {test creation of Device class instance and getName interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst configure -name]
} -result m1 -cleanup {
    unset elemInst result
}

test testDeviceClass-2 {} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst actOnPin -get -all]
} -result {d netd g netg s nets} -cleanup {
    unset elemInst result
}

testTemplate testDeviceClass-3 {} {Device new M1 {{d netg} {g netg} {s nets} {s netg}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}}\
        {Pins list 'd g s s' has already contains pin with name 's'}

test testDeviceClass-4 {} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst actOnParam -get -all]
} -result {vth0 0.7 u0 100 k1 1.5e-3} -cleanup {
    unset elemInst result
}

testTemplate testDeviceClass-5 {} {Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3} {VTH0 0.2}}}\
        {Parameters list 'vth0 u0 k1 vth0' has already contains parameter with name 'vth0'}
testTemplate testDeviceClass-6 {} {Device new 11 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}}\
        {Reference name '11' is not a valid name}
testTemplate testDeviceClass-7 {} {Device new M1. {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 5e-3}}}\
        {Reference name 'M1.' is not a valid name}

test testDeviceClass-8 {test creation of Device class instance and addParam interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    $elemInst actOnParam -add K2 -1.2e-4
    set result [$elemInst actOnParam -get -all]
} -result {vth0 0.7 u0 100 k1 1.5e-3 k2 -1.2e-4} -cleanup {
    unset elemInst result
}

test testDeviceClass-9 {test creation of Device class instance and deleteParam interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    $elemInst actOnParam -delete vth0
    set result [$elemInst actOnParam -get -all]
} -result {u0 100 k1 1.5e-3} -cleanup {
    unset elemInst result
}

testTemplate testDeviceClass-10 {} {Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}}\
        {m1 netd netg nets vth0=0.7 u0=100 k1=1.5e-3}

test testDeviceClass-11 {} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
    $elemInst actOnPin -set g n123
} -body {
    set result [$elemInst actOnPin -get -all]
} -result {d netd g n123 s nets} -cleanup {
    unset elemInst result
}

test testDeviceClass-12 {} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst actOnPin -set p n123} errorStr
    return $errorStr
} -result {Pin with name 'p' was not found in device's 'm1' list of pins 'd g s'} -cleanup {
    unset elemInst errorStr
}

test testDeviceClass-13 {test creation of Device class instance and test setParamValue} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
    $elemInst actOnParam -set vth0 1.0
} -body {
    set result [$elemInst actOnParam -get -all]
} -result {vth0 1.0 u0 100 k1 1.5e-3} -cleanup {
    unset elemInst result
}

test testDeviceClass-14 {test creation of Device class instance and test setParamValue with parameter name not in the parameter list of device} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst actOnParam -set VTH01 1.0} errorStr
    return $errorStr
} -result {Parameter with name 'vth01' was not found in element's 'm1' list of parameters 'vth0 u0 k1'} -cleanup {
    unset elemInst errorStr
}

test testDeviceClass-15 {test creation of Device class instance and test deleteParam with parameter name not in the parameter list of device} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst actOnParam -delete VTH01} errorStr
    return $errorStr
} -result {Parameter with name 'vth01' was not found in device's 'm1' list of parameters 'vth0 u0 k1'} -cleanup {
    unset elemInst errorStr
}

testTemplate testDeviceClass-16 {} {Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {-pos U0 100} {K1 1.5e-3}}}\
        {m1 netd netg nets vth0=0.7 100 k1=1.5e-3}
testTemplate testDeviceClass-17 {} {Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {-poseq U0 {u1+u2}} {K1 1.5e-3}}}\
        {m1 netd netg nets vth0=0.7 {u1+u2} k1=1.5e-3}
testTemplate testDeviceClass-18 {} {Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {-eq U0 {u1+u2}} {K1 1.5e-3}}}\
        {m1 netd netg nets vth0=0.7 u0={u1+u2} k1=1.5e-3}
testTemplate testDeviceClass-19 {} {Device new M1 {{d netd} {g netg} {s {}}} {{VTH0 0.7} {-pos U0 100} {K1 1.5e-3}}}\
        {Device 'm1' can't be netlisted because 's' pin is floating}

test testDeviceClass-20 {test creation of Device class instance and checkFloatingPins interface} -setup {
    set elemInst [Device new M1 {{d netd} {g {}} {s nets} {p {}}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst checkFloatingPins]
} -result {g p} -cleanup {
    unset elemInst result
}

testTemplate testDeviceClass-21 {} {Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}}\
        {m1 netd netg nets vth0=0.7 u0=100 k1=1.5e-3}

test testDeviceClass-22 {test creation of Device class instance and test setParamValue with multiple parameters} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst actOnParam -set VTH0 1.0 U0 50 K1} errorStr
    return $errorStr
} -result {Number of arguments to method 'actOnParam' with '-set' switch must be even} -cleanup {
    unset elemInst errorStr
}

testTemplate testDeviceClass-23 {} {Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {-sw K1}}}\
        {m1 netg netg nets vth0=0.7 u0=100 k1}
testTemplate testDeviceClass-24 {} {Device new M1 {{d netd} {g netg} {s nets}} {}} {m1 netd netg nets}
testTemplate testDeviceClass-25 {} {Device new M1 {} {}} {m1}

testTemplate testDeviceClass-26 {} {Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}}\
        {m1 netd netg nets vth0=0.7 u0=100 k1=1.5e-3}

test testDeviceClass-26 {test creation of Device class instance and test setParamValue with multiple parameters} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    $elemInst actOnParam -set VTH0 1.0 U0 50
    return [$elemInst genSPICEString]
} -result {m1 netd netg nets vth0=1.0 u0=50 k1=1.5e-3} -cleanup {
    unset elemInst
}

###  Model class tests 
    
test testModelClass-1 {test creation of Model class instance and getType interface} -setup {
    set modelInst [Model new MOD1 NMOS {{VTH0 0.7} {U0 100} {VTH1 1} {K1 1.5e-3}}]
} -body {
    set result [$modelInst configure -type]
} -result nmos -cleanup {
    unset modelInst result
}

test testModelClass-2 {} -setup {
    set modelInst [Model new MOD1 NMOS {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$modelInst actOnParam -get -all]
} -result {vth0 0.7 u0 100 k1 1.5e-3} -cleanup {
    unset modelInst result
}

testTemplate testModelClass-3 {} {Model new MOD1 NMOS {{VTH0 0.7} {U0 100} {K1 1.5e-3}}}\
        {.model mod1 nmos(vth0=0.7 u0=100 k1=1.5e-3)}
testTemplate testModelClass-4 {} {Model new MOD1 NMOS {{VTH0 0.7} {-eq U0 v2*vb/2} {K1 1.5e-3}}}\
        {.model mod1 nmos(vth0=0.7 u0={v2*vb/2} k1=1.5e-3)}
testTemplate testModelClass-5 {} {Model new MOD1 NMOS {}} {.model mod1 nmos}


###  RawString class tests 

testTemplate testRawStringClass-1 {} {RawString new {arbitary string}} {arbitary string}
 
test testRawStringClass-2 {test creation of RawString class instance with -name argument and getName interface} -setup {
    set raw [RawString new {arbitary string} -name raw1]
} -body {
    set result [$raw configure -name]
} -result raw1 -cleanup {
    unset raw result
}

#test testRawStringClass-3 {test creation of RawString class instance without -name argument and getName interface} -setup {
#    set raw [RawString new {arbitary string}]
#} -body {
#    set result [$raw getName]
#} -result $raw

###  Comment class tests 

testTemplate testCommentClass-1 {} {Comment new {comment string}} {*comment string}
testTemplate testCommentClass-2 {} {Comment new {comment string1
comment string2
comment string3}} {*comment string1
*comment string2
*comment string3}

###  Temp class tests 

testTemplate testTempClass-1 {} {Temp new 10} {.temp 10}
testTemplate testTempClass-2 {} {Temp new -eq temp} {.temp {temp}}
  
test testTempClass-3 {test creation of Temp class instance and getValue interface} -setup {
    set temp [Temp new -eq temp]
} -body {
    set result [$temp configure -value]
} -result temp -cleanup {
    unset temp result
}

test testTempClass-4 {test creation of Temp class instance and setValue interface} -setup {
    set temp [Temp new -eq temp]
} -body {
    $temp configure -value [list -eq temp1]
    set result [$temp configure -value]
} -result temp1 -cleanup {
    unset temp result
}
    
test testTempClass-5 {test creation of Temp class instance and setValue interface with change of parameter type to equational} -setup {
    set temp [Temp new 10]
} -body {
    $temp configure -value [list -eq temp1]
    set result [$temp configure -value]
} -result temp1 -cleanup {
    unset temp result
}

test testTempClass-6 {test creation of Temp class instance and genSPICEString interface} -body {
    set temp [Temp new 10]
    catch {$temp configure -value [list -e2q temp1]} errorStr
    return $errorStr
} -result {Wrong value '-e2q' of qualifier} -cleanup {
    unset errorStr temp
}
    
###  Include class definition 

testTemplate testIncludeClass-1 {} {Include new {./libs/mosfets/nmos1}} {.include ./libs/mosfets/nmos1}
testTemplate testIncludeClass-2 {} {Include new {./Libs/mosfets/nmos1}} {.include ./Libs/mosfets/nmos1}

###  Library class definition 

testTemplate testLibraryClass-1 {} {Library new ./libs/mosfets/nmos1 slow_corner} {.lib ./libs/mosfets/nmos1 slow_corner}

test testLibraryClass-2 {test creation of Library class instance and getLibValue interface} -setup {
    set raw [Library new ./libs/mosfets/nmos1 slow_corner]
} -body {
    set result [$raw configure -libvalue]
} -result {slow_corner} -cleanup {
    unset raw result
}
    
###  Options class tests 

test testOptionsClass-1 {} -setup {
    set elemInst [Options new {{abstol 1e-12} {-sw noopiter} {gmin 1e-12}}]
} -body {
    set result [$elemInst actOnParam -get -all]
} -result {abstol 1e-12 noopiter {} gmin 1e-12} -cleanup {
    unset elemInst result
}

testTemplate testOptionsClass-2 {} {Options new {{abstol 1e-12} {-sw noopiter} {gmin 1e-12}}}\
        {.options abstol=1e-12 noopiter gmin=1e-12}

test testOptionsClass-3 {test creation of Options class instance and addParam interface} -setup {
    set elemInst [Options new {{abstol 1e-12} {-sw noopiter} {gmin 1e-12}}]
    $elemInst actOnParam -add vntol 1e-4
} -body {
    set result [$elemInst genSPICEString]
} -result {.options abstol=1e-12 noopiter gmin=1e-12 vntol=1e-4} -cleanup {
    unset elemInst result
}

testTemplate testOptionsClass-4 {} {Options new {{abstol 1e-12} {-sw noopiter} {gmin 1e-12}}}\
        {.options abstol=1e-12 noopiter gmin=1e-12}

test testOptionsClass-5 {test creation of Options class instance and addParam interface with adding switch parameter} -setup {
    set elemInst [Options new {{abstol 1e-12} {vntol 1e-4} {-eq gmin gminval}}]
    $elemInst actOnParam -add -sw noopiter 
} -body {
    set result [$elemInst genSPICEString]
} -result {.options abstol=1e-12 vntol=1e-4 gmin={gminval} noopiter} -cleanup {
    unset elemInst result
}

test testOptionsClass-6 {test creation of Options class instance and deleteParam interface} -setup {
    set elemInst [Options new {{abstol 1e-12} {-sw noopiter} {gmin 1e-12}}]
    $elemInst actOnParam -delete gmin
} -body {
    set result [$elemInst genSPICEString]
} -result {.options abstol=1e-12 noopiter} -cleanup {
    unset elemInst result
}

testTemplate testOptionsClass-7 {} {Options new {{abstol 1e-12} {noopiter} {gmin 1e-12}}}\
        {Value 'noopiter' is not a valid value}
testTemplate testOptionsClass-8 {} {Options new {{abstol 1e-12} {gmin 1e-12} {gmin 1e-12}}}\
        {Parameters list 'abstol gmin gmin' has already contains parameter with name 'gmin'}

###  ParamStatement class tests 

testTemplate testParamStatementClass-1 {} {ParamStatement new {{-eq U0T rf+1} {vth0 10}}} {.param u0t={rf+1} vth0=10}

test testParamStatementClass-2 {test creation of ParamStatement class instance and addParam interface} -setup {
    set elemInst [ParamStatement new {{-eq U0T rf+1} {vth0 10}}]
    $elemInst actOnParam -add k1 1e-4
} -body {
    set result [$elemInst genSPICEString]
} -result {.param u0t={rf+1} vth0=10 k1=1e-4} -cleanup {
    unset elemInst result
}

test testParamStatementClass-4 {test creation of ParamStatement class instance and addParam interface with adding equation parameter} -setup {
    set elemInst [ParamStatement new {{k1 1e-4} {vth0 10}}]
    $elemInst actOnParam -add -eq U0T {rf+1}
} -body {
    set result [$elemInst actOnParam -get -all]
} -result {k1 1e-4 vth0 10 u0t rf+1} -cleanup {
    unset elemInst result
}

testTemplate testParamStatementClass-5 {} {ParamStatement new {{U0T rf+1} {vth0 10}}} {Value 'rf+1' is not a valid value}

test testParamStatementClass-6 {test creation of ParamStatement class instance and setParamValue interface} -setup {
    set elemInst [ParamStatement new {{-eq U0T rf+1} {vth0 10}}]
} -body {
    $elemInst actOnParam -set u0t 2
    set result [$elemInst actOnParam -get -all]
} -result {u0t 2 vth0 10} -cleanup {
    unset elemInst result
}

testTemplate testParamStatementClass-7 {} {ParamStatement new {{-eq U0T rf+1} {U0T 10}}}\
        {Parameters list 'u0t u0t' has already contains parameter with name 'u0t'}
testTemplate testParamStatementClass-8 {} {ParamStatement new {{-eq U0T rf+1} {U0T}}} {Value 'U0T' is not a valid value}

###  Save class tests

testTemplate testSaveClass-8 {} {Save new {v(node) i(vin) vsource#branch @m2[vdsat] node}}\
        {.save v(node) i(vin) vsource#branch @m2[vdsat] node}

test testSaveClass-2 {} -setup {
    set elemInst [Save new {v(node) i(vin) vsource#branch @m2[vdsat] node}]
} -body {
    $elemInst addVector node5
    set result [$elemInst genSPICEString]
} -result {.save v(node) i(vin) vsource#branch @m2[vdsat] node node5} -cleanup {
    unset elemInst result
}

test testSaveClass-3 {} -setup {
    set elemInst [Save new {v(node) i(vin) vsource#branch @m2[vdsat] node}]
} -body {
    $elemInst deleteVector vsource#branch
    set result [$elemInst genSPICEString]
} -result {.save v(node) i(vin) @m2[vdsat] node} -cleanup {
    unset elemInst result
}

test testSaveClass-4 {} -setup {
    set elemInst [Save new {v(node) i(vin) vsource#branch @m2[vdsat] node} -name save1]
} -body {
    catch {$elemInst deleteVector {i(vin1)}} errorStr
    return $errorStr
} -result {Vector with name 'i(vin1)' was not found in device's 'save1' list of parameters 'v(node) i(vin)\
vsource#branch {@m2[vdsat]} node'} -cleanup {
    unset elemInst errorStr
}

test testSaveClass-5 {} -setup {
    set elemInst [Save new {v(node) i(vin) vsource#branch @m2[vdsat] node} -name save1]
} -body {
    catch {$elemInst addVector {i(vin)}} errorStr
    return $errorStr
} -result {Vectors list 'v(node) i(vin) vsource#branch {@m2[vdsat]} node i(vin)' has already contains vector with name\
'i(vin)'} -cleanup {
    unset elemInst errorStr
}

###  Ic class tests 

testTemplate testIcClass-1 {} {Ic new {{-eq v(a) v1} {v(b) 10}}} {.ic v(a)={v1} v(b)=10}
testTemplate testIcClass-2 {} {Ic new {{-eq a v1} {b 10}}} {.ic a={v1} b=10}
testTemplate testIcClass-3 {} {Ic new {{-eq a v1} {a 10}}}\
        {Parameters list 'a a' has already contains parameter with name 'a'}
testTemplate testIcClass-4 {} {Ic new {{-eq a v1} {a}}} {Value 'a' is not a valid value}

###  Nodeset class tests 

testTemplate testNodesetClass-1 {} {Nodeset new {{-eq v(a) v1} {v(b) 10}}} {.nodeset v(a)={v1} v(b)=10}
testTemplate testNodesetClass-2 {} {Nodeset new {{-eq a v1} {b 10}}} {.nodeset a={v1} b=10}

###  Global class tests 

testTemplate testGlobalClass-1 {} {Global new {gnd1 gnd2 g}} {.global gnd1 gnd2 g}

test testGlobalClass-2 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1 gnd2 g}]
} -body {
    $elemInst addNets {gnd5 gnd6}
    set result [$elemInst genSPICEString]
} -result {.global gnd1 gnd2 g gnd5 gnd6} -cleanup {
    unset elemInst result
}

test testGlobalClass-3 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1 gnd2 g}]
} -body {
    $elemInst deleteNet {gnd2}
    set result [$elemInst genSPICEString]
} -result {.global gnd1 g} -cleanup {
    unset elemInst result
}

test testGlobalClass-4 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1 gnd2 g} -name glob1]
} -body {
    catch {$elemInst addNets {gnd3 gnd2}} errorStr
    return $errorStr
} -result {Net with name 'gnd2' is already attached to the object 'glob1'} -cleanup {
    unset elemInst errorStr
}

test testGlobalClass-5 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1 gnd2 g}]
} -body {
    catch {$elemInst addNets {gnd3 {}}} errorStr
    return $errorStr
} -result {Net name couldn't be empty} -cleanup {
    unset elemInst errorStr
}

test testGlobalClass-6 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1} -name glob1]
} -body {
    $elemInst deleteNet gnd1
    catch {$elemInst deleteNet gnd2} errorStr
    return $errorStr
} -result {Global statement 'glob1' doesn't have attached net with name 'gnd2'} -cleanup {
    unset elemInst errorStr
}

###  Netlist class tests 
    
test testNetlistClass-1 {test creation of Netlist class instance with add interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {-eq {r1+5/10}}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    set result [$netlistInst genSPICEString]
} -result {r1 net1 net2 10
r2 net1 net2 {r1+5/10}
c1 net2 net3 1e-6
.param r1=1 r2=2
*some random comment
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string
v1 net1 net3 5} -cleanup {
    unset netlistInst result
}

test testNetlistClass-2 {test creation of Netlist class instance with del interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10] [R new 2 net1 net2 -r {-eq {r1+5/10}}]\
            [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
    $netlistInst add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    $netlistInst del V1
    set result [$netlistInst genSPICEString]
} -result {r1 net1 net2 10
r2 net1 net2 {r1+5/10}
r5 net1 net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
c1 net2 net3 1e-6
.param r1=1 r2=2
*some random comment
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string} -cleanup {
    unset netlistInst result
} 

test testNetlistClass-3 {test creation of Netlist class instance with del interface with wrong name of element} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {-eq {r1+5/10}}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    catch {$netlistInst del r3} errorStr
    return $errorStr
} -result {Element with name 'r3' was not found in netlist's 'new_netlist' list of elements} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-4 {test creation of Netlist class instance and getElement interface} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {-eq {r1+5/10}}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    set elementObj [$netlistInst getElement r2]
    return [$elementObj configure -name]
} -result r2 -cleanup {
    unset netlistInst elementObj
}

test testNetlistClass-5 {test creation of Netlist class instance with add element with same name as ones already added to netslit} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {-eq {r1+5/10}}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    catch {$netlistInst add [R new 1 net1 net2 -r 15]} errorStr
    return $errorStr
} -result {Netlist 'new_netlist' already contains element with name r1} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-6 {test creation of Netlist class instance and modifying value of netlist element} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {-eq {r1+5/10}}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    set resistor [$netlistInst getElement r1]
    $resistor actOnParam -set r 100
    return [$netlistInst genSPICEString]
} -result {r1 net1 net2 100
r2 net1 net2 {r1+5/10}
c1 net2 net3 1e-6
.param r1=1 r2=2
*some random comment
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string
v1 net1 net3 5} -cleanup {
    unset netlistInst resistor
}

test testNetlistClass-7 {test creation of Netlist class instance with add element with same name as ones already added to netslit} -setup {
    set netlistInst [Netlist new new_netlist]
} -body {
    catch {$netlistInst add [R new 1 net1 net2 -r 10] [R new 1 net1 net2 -r 15]} errorStr
    return $errorStr
} -result {Netlist 'new_netlist' already contains element with name r1} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-8 {test creation of Netlist class instance with del interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10] [R new 2 net1 net2 -r {-eq {r1+5/10}}]\
            [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
    $netlistInst add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    $netlistInst del V1 com1
    set result [$netlistInst genSPICEString]
} -result {r1 net1 net2 10
r2 net1 net2 {r1+5/10}
r5 net1 net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
c1 net2 net3 1e-6
.param r1=1 r2=2
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string} -cleanup {
    unset netlistInst result
}

test testNetlistClass-9 {test creation of Netlist class instance with del interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10] [R new 2 net1 net2 -r {-eq {r1+5/10}}]\
            [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
    $netlistInst add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    catch {$netlistInst del V1 com1 V1} errorStr
    return $errorStr
} -result {Element with name 'v1' was not found in netlist's 'newnetlist' list of elements} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-10 {test creation of Netlist class instance with del interface} -setup {
    set netlistInst [Netlist new newNetlist]
} -body {
    catch {$netlistInst del V1} errorStr
    return $errorStr
} -result {Netlist 'newnetlist' doesn't have attached elements} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-11 {test creation of Netlist class instance with del interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10] [R new 2 net1 net2 -r {-eq {r1+5/10}}]\
            [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
    $netlistInst add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    catch {$netlistInst getElement v5} errorStr
    return $errorStr
} -result {Element with name 'v5' was not found in netlist's 'newnetlist' list of elements} -cleanup {
    unset netlistInst errorStr
}
    
###  Subcircuit class tests 

test testSubcircuitClass-1 {test creation of Subcircuit class instance with genSPICEString interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {-eq r}] [C new 1 net2 net3 -c {-eq c}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit genSPICEString]
    
} -result {.subckt rcnet plus minus r=100 c=1e-6
r1 net1 net2 {r}
c1 net2 net3 {c}
.ends rcnet} -cleanup {
    rename RCnet ""
    unset subcircuit result
}

test testSubcircuitClass-2 {test creation of Subcircuit class instance with getPins interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {-eq r}]
            my add [C new 1 net2 net3 -c {-eq c}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit actOnPin -get -all]
} -result {plus {} minus {}} -cleanup {
    rename RCnet ""
    unset subcircuit result
}
 
test testSubcircuitClass-3 {test creation of Subcircuit class instance with getParams interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {-eq r}]
            my add [C new 1 net2 net3 -c {-eq c}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit actOnParam -get -all]
} -result {r 100 c 1e-6} -cleanup {
    rename RCnet ""
    unset subcircuit result
}
 
test testSubcircuitClass-4 {test creation of Subcircuit class instance with forbidden element adding} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {-eq r}]
            my add [C new 1 net2 net3 -c {-eq c}]
            my add [Include new {/fold1/fold2/file.lib} -name inc1]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    
} -body {
    catch {RCnet new} errorStr
    set result $errorStr
} -result {::SpiceGenTcl::Include element can't be included in subcircuit} -cleanup {
    rename RCnet ""
    unset result errorStr
}

test testSubcircuitClass-5 {test creation of Subcircuit class instance with forbidden element Analysis} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {-eq r}]
            my add [C new 1 net2 net3 -c {-eq c}]
            my add [Op new]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    
} -body {
    catch {RCnet new} errorStr
    set result $errorStr
} -result {Analysis element can't be included in subcircuit} -cleanup {
    rename RCnet ""
    unset result errorStr
}

test testSubcircuitClass-6 {test creation of Subcircuit class instance with genSPICEString interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {-eq r}]
            my add [C new 1 net2 net3 -c {-eq c}]
            my add [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
            my add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit genSPICEString]
} -result {.subckt rcnet plus minus r=100 c=1e-6
r1 net1 net2 {r}
c1 net2 net3 {c}
r5 net1 net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
.ends rcnet} -cleanup {
    rename RCnet ""
    unset subcircuit result
}

test testSubcircuitClass-7 {test creation of Subcircuit class instance with nested subcircuit} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 plus -r {-eq r}]
            my add [C new 1 net2 net3 -c {-eq c}]
            my add [R new 5 minus net2 -model res_sem -l 10e-6 -w 100e-6]
            my add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]

            oo::class create RCnetNest {
                superclass Subcircuit
                constructor {} {
                    set pins {plus minus}
                    set params {{r 100} {c 1e-6}}
                    my add [R new 1 net1 plus -r {-eq r}]
                    my add [C new 1 net2 net3 -c {-eq c}]
                    next rcnetnest $pins $params
                }
            }
            set subcircuitNest [RCnetNest new]
            my add $subcircuitNest
            my add [SubcircuitInstanceAuto new $subcircuitNest 2 {net1 net2} -r 1 -c {-eq cpar}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit genSPICEString]
    
} -result {.subckt rcnet plus minus r=100 c=1e-6
r1 net1 plus {r}
c1 net2 net3 {c}
r5 minus net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
.subckt rcnetnest plus minus r=100 c=1e-6
r1 net1 plus {r}
c1 net2 net3 {c}
.ends rcnetnest
x2 net1 net2 rcnetnest r=1 c={cpar}
.ends rcnet} -cleanup {
    rename RCnet ""
    unset subcircuit result
}

test testSubcircuitClass-7.1 {test creation of Subcircuit class instance with nested subcircuit} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 plus -r {-eq r}]
            my add [C new 1 net2 net3 -c {-eq c}]
            my add [R new 5 minus net2 -model res_sem -l 10e-6 -w 100e-6]
            my add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
    namespace eval [info object namespace $subcircuit] {           
        oo::class create RCnetNest {
            superclass Subcircuit
            constructor {} {
                set pins {plus minus}
                set params {{r 100} {c 1e-6}}
                my add [R new 1 net1 plus -r {-eq r}]
                my add [C new 1 net2 net3 -c {-eq c}]
                next rcnetnest $pins $params
            }
        }
        set subcircuitNest [RCnetNest new]
        my add $subcircuitNest
        my add [SubcircuitInstanceAuto new $subcircuitNest 2 {net1 net2} -r 1 -c {-eq cpar}]
    }

} -body {
    set result [$subcircuit genSPICEString]
    
} -result {.subckt rcnet plus minus r=100 c=1e-6
r1 net1 plus {r}
c1 net2 net3 {c}
r5 minus net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
.subckt rcnetnest plus minus r=100 c=1e-6
r1 net1 plus {r}
c1 net2 net3 {c}
.ends rcnetnest
x2 net1 net2 rcnetnest r=1 c={cpar}
.ends rcnet} -cleanup {
    rename RCnet ""
    unset subcircuit result
}

test testSubcircuitClass-8 {test creation of Subcircuit class instance with genSPICEString interface} -body {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {r 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {-eq r}] [C new 1 net2 net3 -c {-eq c}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    catch {RCnet new} errorStr
    return $errorStr
} -result {Parameters list 'r r' has already contains parameter with name 'r'} -cleanup {
    rename RCnet ""
    unset errorStr
}

test testSubcircuitClass-9 {test creation of Subcircuit class instance with genSPICEString interface} -body {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {-eq c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {-eq r}] [C new 1 net2 net3 -c {-eq c}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    catch {RCnet new} errorStr
    return $errorStr
} -result {Wrong parameter '-eq c 1e-6' definition in subcircuit 'rcnet'} -cleanup {
    rename RCnet ""
    unset errorStr
}

###  Analysis class tests 
    
test testAnalysisClass-1 {} -setup {
    set anInst [Analysis new dc {{-posnocheck srcnam v1} {-pos vstart 0} {-pos vstop 5} {-pos vincr 0.1}}]
} -body {
    set result [$anInst actOnParam -get -all]
} -result {srcnam v1 vstart 0 vstop 5 vincr 0.1} -cleanup {
    unset anInst result
}

testTemplate testAnalysisClass-2 {}\
        {Analysis new dc {{-posnocheck srcnam v1} {-pos vstart 0} {-pos vstop 5} {-pos vincr 0.1}}} {.dc v1 0 5 0.1}
testTemplate testAnalysisClass-3 {}\
        {Analysis new dc1 {{-posnocheck srcnam v1} {-pos vstart 0} {-pos vstop 5} {-pos vincr 0.1}}}\
        {Type 'dc1' is not in supported list of analysis, should be one of 'ac dc tran op disto noise pz sens sp tf'}

test testAnalysisClass-4 {} -setup {
    set anInst [Analysis new dc {{-posnocheck srcnam v1} {-pos vstart 0} {-pos vstop 5} {-pos vincr 0.1}}]
    $anInst actOnParam -set vstop 10
} -body {
    return [$anInst genSPICEString]   
} -result {.dc v1 0 10 0.1} -cleanup {
    unset anInst
}

testTemplate testAnalysisClass-5 {}\
        {Analysis new dc {{-posnocheck srcnam v1} {-pos vstart 0} {-poseq vstop x**2+1} {-pos vincr 0.1}}}\
        {.dc v1 0 {x**2+1} 0.1}
testTemplate testAnalysisClass-6 {} {Analysis new tran {{-pos tstep 1e-6} {-pos tstop 10e-3} {-sw uic}}}\
        {.tran 1e-6 10e-3 uic}
testTemplate testAnalysisClass-7 {} {Analysis new dc {{-posnocheck srcnam v1} {vstart} {-pos vstop 5} {-pos vincr 0.1}}}\
        {Value 'vstart' is not a valid value}

###  RawFile class tests 

test testRawFileClass-1 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    set data [$dataObj getTracesCsv -all]
    return $data
} -result {v(v-sweep),v(in),v(out),i(v1)
0.0,0.0,0.0,0.0
1.0,1.0,0.6666666666666666,-0.0003333333333333334
2.0,2.0,1.3333333333333333,-0.0006666666666666668
3.0,3.0,2.0,-0.001
4.0,4.0,2.6666666666666665,-0.0013333333333333335
5.0,5.0,3.333333333333333,-0.001666666666666667
} -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-2 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    set data [$dataObj getTracesCsv -all -sep ,,]
    return $data
} -result {v(v-sweep),,v(in),,v(out),,i(v1)
0.0,,0.0,,0.0,,0.0
1.0,,1.0,,0.6666666666666666,,-0.0003333333333333334
2.0,,2.0,,1.3333333333333333,,-0.0006666666666666668
3.0,,3.0,,2.0,,-0.001
4.0,,4.0,,2.6666666666666665,,-0.0013333333333333335
5.0,,5.0,,3.333333333333333,,-0.001666666666666667
} -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-3 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    set data [$dataObj getTracesCsv -traces v(in) v(out)]
    return $data
} -result {v(in),v(out)
0.0,0.0
1.0,0.6666666666666666
2.0,1.3333333333333333
3.0,2.0
4.0,2.6666666666666665
5.0,3.333333333333333
} -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-4 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    catch {$dataObj getTracesCsv -traces v(in1) v(out)} errorStr
    return $errorStr
} -result {Trace with name 'v(in1)' was not found in raw file './voltage divider netlist.raw' list of traces} -cleanup {
    unset circuit errorStr simulator dataObj
}

test testRawFileClass-5 {test creation of RawFile class instance and getTracesCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    catch {$dataObj getTracesCsv} errorStr
    return $errorStr
} -result {Arguments '-all' or '-traces traceName1 traceName2 ...' must be provided to 'getTracesCsv' method} -cleanup {
    unset circuit errorStr simulator dataObj
}

test testRawFileClass-6 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    set data [$dataObj getVoltagesNames]
    return $data
} -result {v(v-sweep) v(in) v(out)} -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-6 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    set data [$dataObj getCurrentsNames]
    return $data
} -result i(v1) -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-7 {} -setup {
    set data [RawFile new "${currentDir}/ngspice/raw_data_ngspice/tran.raw"]
} -body {
    return [$data measure -avg {-vec v(vdd)}]
} -result 3.0000000000000138 -cleanup {
    unset data
}

test testRawFileClass-8 {} -setup {
    set data [RawFile new "${currentDir}/ngspice/raw_data_ngspice/tran.raw"]
} -body {
    return [$data measure -when {-vec v(osc_out) -val 0.5 -rise 3}]
} -result 8.699963889119589e-9 -cleanup {
    unset data
}

test testRawFileClass-9 {} -setup {
    set data [RawFile new "${currentDir}/ngspice/raw_data_ngspice/tran.raw"]
} -body {
    return [$data measure -find v(osc_out) -when {-vec v(osc_out) -val 0.5 -rise 3}]
} -result 0.4999999999999959 -cleanup {
    unset data
}

test testRawFileClass-10 {} -setup {
    set data [RawFile new "${currentDir}/ngspice/raw_data_ngspice/tran.raw"]
} -body {
    return [$data measure -find v(vdd) -when {-vec v(osc_out) -val 0.5 -rise 3}]
} -result 3.0 -cleanup {
    unset data
}


###  Circuit class tests 

test testCircuitClass-1 {test creation of Circuit class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3] [R new 2 out 0 -r 2e3] 
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
} -body {
    set data [$circuit getDataCsv -traces v(in) v(out)]
    return $data
} -result {v(in),v(out)
0.0,0.0
1.0,0.6666666666666666
2.0,1.3333333333333333
3.0,2.0
4.0,2.6666666666666665
5.0,3.333333333333333
} -cleanup {
    unset circuit data simulator
}

test testCircuitClass-2 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
} -body {
    catch {$circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]} errorStr
    return $errorStr
} -result {Netlist 'voltage divider netlist' already contains Analysis element} -cleanup {
    unset circuit errorStr
}

test testCircuitClass-3 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
} -body {
    catch {$circuit add [R new 1 out 0 -r 2e3]} errorStr
    return $errorStr
} -result {Netlist 'voltage divider netlist' already contains element with name r1} -cleanup {
    unset circuit errorStr
}

test testCircuitClass-4 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
} -body {
    catch {$circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1] [Dc new -src v1 -start 0 -stop 5 -incr 1]} errorStr
    return $errorStr
} -result {Netlist 'voltage divider netlist' already contains Analysis element} -cleanup {
    unset circuit errorStr
}

test testCircuitClass-5 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3] [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
} -body {
    $circuit del R2 r1
    return [$circuit genSPICEString]
} -result {voltage divider netlist
v1 in 0 1
.dc v1 0 5 1} -cleanup {
    unset circuit
}

test testCircuitClass-6 {test creation of Circuit class instance, add Anslysis, remove it and then add again} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1 -name dc1]
    $circuit del dc1
} -body {
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1 -name dc1]
    return [$circuit genSPICEString]
} -result {voltage divider netlist
v1 in 0 1
r1 in out 1e3
r2 out 0 2e3
.dc v1 0 5 1} -cleanup {
    unset circuit
}

test testCircuitClass-7 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
} -body {
    catch {$circuit del v1} errorStr
    return $errorStr
} -result {Netlist 'voltage divider netlist' doesn't have attached elements} -cleanup {
    unset circuit errorStr
}

test testCircuitClass-8 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
} -body {
    catch {$circuit del v5} errorStr
    return $errorStr
} -result {Element with name 'v5' was not found in circuit's 'voltage divider netlist' list of elements} -cleanup {
    unset circuit errorStr
}

test testCircuitClass-9 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
} -body {
    catch {$circuit getElement v5} errorStr
    return $errorStr
} -result {Element with name 'v5' was not found in netlist's 'voltage divider netlist' list of elements} -cleanup {
    unset circuit errorStr
}

test testCircuitClass-10 {test creation of Circuit class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3] [R new 2 out 0 -r 2e3] 
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
} -body {
    $circuit detachSimulator
    catch {$circuit configure -simulator} errorStr
    return $errorStr
} -result {can't read "simulator": no such variable} -cleanup {
    unset circuit simulator errorStr
}

test testCircuitClass-11 {test creation of Circuit class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3] [R new 2 out 0 -r 2e3] 
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
} -body {
    catch {$circuit runAndRead} errorStr
    return $errorStr
} -result {Simulator is not attached to 'voltage divider netlist' circuit} -cleanup {
    unset circuit errorStr
}

test testCircuitClass-12 {test creation of Circuit class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3] [R new 2 out 0 -r 2e3] 
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead -nodelete
} -body {
    set data [$circuit getDataCsv -traces v(in) v(out)]
    return $data
} -result {v(in),v(out)
0.0,0.0
1.0,0.6666666666666666
2.0,1.3333333333333333
3.0,2.0
4.0,2.6666666666666665
5.0,3.333333333333333
} -cleanup {
    unset circuit data simulator
    file delete {voltage divider netlist.cir}
    file delete {voltage divider netlist.log}
    file delete {voltage divider netlist.raw}
}

###  Parser class tests 

test testParserClass-1 {test creation of Parser class instance} -setup {
    set parser [Parser new {voltage divider netlist} path]
} -body {
    catch {$parser readFile} errorStr
    return $errorStr
} -result {Not implemented} -cleanup {
    unset parser errorStr
}

test testParserClass-2 {test creation of Parser class instance} -setup {
    set parser [Parser new {voltage divider netlist} path]
} -body {
    catch {$parser readAndParse} errorStr
    return $errorStr
} -result {Not implemented} -cleanup {
    unset parser errorStr
}

test testParserClass-5 {test creation of Parser class instance} -setup {
    set parser [Parser new {voltage divider netlist} path]
} -body {
    catch {$parser buildTopNetlist} errorStr
    return $errorStr
} -result {Parser object 'voltage divider netlist' doesn't have prepared data} -cleanup {
    unset parser errorStr
}

###  Simulator class tests

test testSimulatorClass-1 {} -setup {
    oo::configurable create DummyClass {
        superclass ::SpiceGenTcl::Simulator
    }
    set inst [DummyClass new]
} -body {
    catch {$inst run} errorStr
    return $errorStr
} -result {Not implemented} -cleanup {
    unset inst errorStr
    DummyClass destroy
}

test testSimulatorClass-2 {} -setup {
    oo::configurable create DummyClass {
        superclass ::SpiceGenTcl::Simulator
    }
    set inst [DummyClass new]
} -body {
    catch {$inst readLog} errorStr
    return $errorStr
} -result {Not implemented} -cleanup {
    unset inst errorStr
    DummyClass destroy
}

test testSimulatorClass-3 {} -setup {
    oo::configurable create DummyClass {
        superclass ::SpiceGenTcl::Simulator
    }
    set inst [DummyClass new]
} -body {
    catch {$inst getLog} errorStr
    return $errorStr
} -result {Not implemented} -cleanup {
    unset inst errorStr
    DummyClass destroy
}

test testSimulatorClass-4 {} -setup {
    oo::configurable create DummyClass {
        superclass ::SpiceGenTcl::Simulator
    }
    set inst [DummyClass new]
} -body {
    catch {$inst readData} errorStr
    return $errorStr
} -result {Not implemented} -cleanup {
    unset inst errorStr
    DummyClass destroy
}

forgetNgspice

cleanupTests
