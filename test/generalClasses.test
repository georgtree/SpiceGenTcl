#  .|'''.|            ||                   ..|'''.|                   |''||''|         '||'
#  ||..  '  ... ...  ...    ....    ....  .|'     '    ....  .. ...      ||      ....   ||  
#   ''|||.   ||'  ||  ||  .|   '' .|...|| ||    .... .|...||  ||  ||     ||    .|   ''  ||  
# .     '||  ||    |  ||  ||      ||      '|.    ||  ||       ||  ||     ||    ||       ||  
# |'....|'   ||...'  .||.  '|...'  '|...'  ''|...'|   '|...' .||. ||.   .||.    '|...' .||. 
#            ||                                                                             
#           ''''                                                                            
# generalClasses.test
# Tests Ngspice simulators classes
#
# Copyright (c) 2024 George Yashin, georgtree@gmail.com
#
# MIT License
# See the file "LICENSE.txt" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

package require tcltest
namespace import ::tcltest::*
package require SpiceGenTcl
namespace import ::SpiceGenTcl::*
set ngspiceNameSpc [namespace children ::SpiceGenTcl::Ngspice]
foreach nameSpc $ngspiceNameSpc {
    namespace import ${nameSpc}::*
}

###  DuplChecker class tests 
    
test testDuplCheckerClass-1.1 {test of duplListCheck procedure} -setup {
    set checker [::SpiceGenTcl::DuplChecker new]
    set testList [list a b f c d e f ]
} -body {
    set result [$checker duplListCheck $testList]
} -result 1 -cleanup {
    unset checker testList result 
}

test testDuplCheckerClass-2 {test of duplListCheck procedure} -setup {
    set checker [::SpiceGenTcl::DuplChecker new]
    set testList [list a b c d e f g]
} -body {
    set result [$checker duplListCheck $testList]
} -result 0 -cleanup {
    unset checker testList result 
}

    
###  Pin class tests 

test testPinClass-1 {test creation of Pin class instance and getName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    set result [$pinInst configure -Name]
} -result drain -cleanup {
    unset pinInst result
}

test testPinClass-2 {test creation of Pin class instance and getName interface} -setup {
    set pinInst [Pin new 23 netd]
} -body {
    set result [$pinInst configure -Name]
} -result 23 -cleanup {
    unset pinInst result
}

test testPinClass-3 {test creation of Pin class instance and getNodeName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    set result [$pinInst configure -NodeName]
} -result netd -cleanup {
    unset pinInst result
}

test testPinClass-4 {test creation of Pin class instance and genSPICEStr interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    set result [$pinInst genSPICEString]
} -result netd -cleanup {
    unset pinInst result
}

test testPinClass-5 {test creation of Pin class instance and checkFloating interface} -setup {
    set pinInst [Pin new drain {}]
} -body {
    set result [$pinInst checkFloating]
} -result true -cleanup {
    unset pinInst result
}

test testPinClass-6 {test creation of Pin class instance and check how genSPICEStr handling floating pin} -setup {
    set pinInst [Pin new drain {}]
} -body {
    catch {$pinInst genSPICEString} errorStr
    return $errorStr
} -result "Pin 'drain' is not connected to the node so can't be netlisted" -cleanup {
    unset pinInst errorStr
}

test testPinClass-7 {test creation of Pin class instance and handling wrong symbols in the name} -body {
    catch {set pinInst [Pin new dr-ain netd]} errorStr
    return $errorStr
} -result "Pin name 'dr-ain' is not a valid name" -cleanup {
    unset errorStr
}

test testPinClass-8 {test creation of Pin class instance and handling wrong symbols in the name} -body {
    catch {set pinInst [Pin new drain. netd]} errorStr
    return $errorStr
} -result "Pin name 'drain.' is not a valid name" -cleanup {
    unset errorStr
}

test testPinClass-9 {test creation of Pin class instance and handling wrong symbols in the name} -body {
    catch {set pinInst [Pin new !drain netd]} errorStr
    return $errorStr
} -result "Pin name '!drain' is not a valid name" -cleanup {
    unset errorStr
}

test testPinClass-10 {test creation of Pin class instance and handling empty string in the name} -body {
    catch {set pinInst [Pin new "" netd]} errorStr
    return $errorStr
} -result "Pin must have a name, empty string was provided" -cleanup {
    unset errorStr
}

test testPinClass-11 {test creation of Pin class instance and setNodeName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    $pinInst configure -NodeName net1
    set result [$pinInst configure -NodeName]
} -result net1 -cleanup {
    unset pinInst result
}
    
test testPinClass-12 {test creation of Pin class instance and setNodeName interface with wrong node name} -setup {
    set pinInst [Pin new drain netd]
} -body {
    catch {$pinInst configure -NodeName n-et1} errorStr
    return $errorStr
} -result "Node name 'n-et1' is not a valid name" -cleanup {
    unset pinInst errorStr
}
    
test testPinClass-13 {test creation of Pin class instance and unsetNodeName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    $pinInst unsetNodeName
    set result [$pinInst configure -NodeName]
} -result {} -cleanup {
    unset pinInst result
}
    
test testPinClass-14 {test creation of Pin class instance and getName interface} -setup {
    set pinInst [Pin new drain_ netd_]
} -body {
    set result [$pinInst configure -Name]
} -result drain_ -cleanup {
    unset pinInst result
}
    
###  Parameter class tests 

test testParameterClass-1 {test creation of Parameter class instance and getName interface} -setup {
    set parInst [Parameter new VTH 0.7]
} -body {
    set result [$parInst configure -Name]
} -result vth -cleanup {
    unset parInst result
}

test testParameterClass-2 {test creation of Parameter class instance and getValue interface} -setup {
    set parInst [Parameter new VTH 0.7]
} -body {
    set result [$parInst configure -Value]
} -result 0.7 -cleanup {
    unset parInst result
}

test testParameterClass-3 {test creation of Parameter class instance and getValue interface} -setup {
    set parInst [Parameter new VTH 0.007e+3]
} -body {
    set result [$parInst configure -Value]
} -result 0.007e+3 -cleanup {
    unset parInst result
}

test testParameterClass-4 {test creation of Parameter class instance and handling wrong symbols in the name}  -body {
    catch {set parInst [Parameter new VT.H 0.7]} errorStr
    return $errorStr
} -result "Parameter name 'VT.H' is not a valid name" -cleanup {
    unset errorStr
}

test testParameterClass-5 {test creation of Parameter class instance and handling empty string in the name}  -body {
    catch {set parInst [Parameter new "" 0.7]} errorStr
    return $errorStr
} -result "Parameter must have a name, empty string was provided" -cleanup {
    unset errorStr
}

test testParameterClass-6 {test creation of Parameter class instance and handling wrong form of the value}  -body {
    catch {set parInst [Parameter new VTH 0.7e-]} errorStr
    return $errorStr
} -result "Value '0.7e-' is not a valid value" -cleanup {
    unset errorStr
}

test testParameterClass-7 {test creation of Parameter class instance and setValue interface} -setup {
    set parInst [Parameter new VTH 0.7]
    $parInst configure -Value 1.0
} -body {
    set result [$parInst configure -Value]
} -result 1.0 -cleanup {
    unset parInst result
}

test testParameterClass-8 {test creation of Parameter class instance and setValue interface with wrong value string} -setup {
    set parInst [Parameter new VTH 0.7]
} -body {
    catch {$parInst configure -Value 1..0} errorStr
    return $errorStr
} -result "Value '1..0' is not a valid value" -cleanup {
    unset parInst errorStr
}

test testParameterClass-9 {test creation of Parameter class instance and getName interface} -setup {
    set parInst [Parameter new VTH 700u]
} -body {
    set result [$parInst configure -Name]
} -result vth -cleanup {
    unset parInst result
}

test testParameterClass-10 {test creation of Parameter class instance and getName interface} -setup {
    set parInst [Parameter new VTH 700U]
} -body {
    set result [$parInst configure -Name]
} -result vth -cleanup {
    unset parInst result
}

test testParameterClass-11 {test creation of Parameter class instance} -setup {
    set parInst [Parameter new GMIN 1.0T]
} -body {
    set result [$parInst configure -Value]
} -result 1.0t -cleanup {
    unset parInst result
}

test testParameterClass-12 {test creation of Parameter class instance} -setup {
    set parInst [Parameter new GMIN 1.0meg]
} -body {
    set result [$parInst configure -Value]
} -result 1.0meg -cleanup {
    unset parInst result
}

test testParameterClass-13 {test creation of Parameter class instance} -setup {
    set parInst [Parameter new GMIN 1e-6Meg]
} -body {
    set result [$parInst configure -Value]
} -result 1e-6meg -cleanup {
    unset parInst result
}

test testParameterClass-14 {test creation of Parameter class instance and handling wrong form of the value}  -body {
    catch {set parInst [Parameter new VTH 700uV]} errorStr
    return $errorStr
} -result "Value '700uV' is not a valid value" -cleanup {
    unset errorStr
}

test testParameterClass-15 {test creation of Parameter class instance and handling wrong form of the value}  -body {
    catch {set parInst [Parameter new VTH 700vu]} errorStr
    return $errorStr
} -result "Value '700vu' is not a valid value" -cleanup {
    unset errorStr
}

###  ParameterNoCheck class tests 

test testParameterNoCheckClass-1 {test creation of ParameterNoCheck class instance} -setup {
    set parInst [ParameterNoCheck new VTH 0.7]
} -body {
    $parInst configure -Value 1..0
    return [$parInst configure -Value]
} -result "1..0" -cleanup {
    unset parInst
}    
    
###  ParameterDefault class tests 

test testParameterDefaultClass-1 {test creation of ParameterDefault class instance and getName interface} -setup {
    set parInst [ParameterDefault new U0 100 200]
} -body {
    set result [$parInst configure -Name]
} -result u0 -cleanup {
    unset parInst result
}

test testParameterDefaultClass-2 {test creation of ParameterDefault class instance and getValue interface} -setup {
    set parInst [ParameterDefault new U0 100 200]
} -body {
    set result [$parInst configure -Value]
} -result 100 -cleanup {
    unset parInst result
}

test testParameterDefaultClass-3 {test creation of ParameterDefault class instance and getDefValue interface} -setup {
    set parInst [ParameterDefault new U0 100 200]
} -body {
    set result [$parInst configure -DefValue]
} -result 200 -cleanup {
    unset parInst result
}

test testParameterDefaultClass-4 {test creation of ParameterDefault class instance and resetValue method} -setup {
    set parInst [ParameterDefault new U0 100 200]
    $parInst resetValue
} -body {
    set result [$parInst configure -Value]
} -result 200 -cleanup {
    unset parInst result
}
    
###  ParameterSwitch class tests 

test testParameterSwitchClass-1 {test creation of ParameterSwitch class instance and getName interface} -setup {
    set parInst [ParameterSwitch new U0]
} -body {
    set result [$parInst configure -Name]
} -result u0 -cleanup {
    unset parInst result
}

test testParameterSwitchClass-2 {test creation of ParameterSwitch class instance and genSPICEString interface} -setup {
    set parInst [ParameterSwitch new U0]
} -body {
    set result [$parInst genSPICEString]
} -result u0 -cleanup {
    unset parInst result
}
    
###  ParameterPositional class tests 

test testParameterPositionalClass-1 {test creation of ParameterPositional class instance and getName interface} -setup {
    set parInst [ParameterPositional new U0 100]
} -body {
    set result [$parInst configure -Name]
} -result u0 -cleanup {
    unset parInst result
}

test testParameterPositionalClass-2 {test creation of ParameterPositional class instance and genSPICEString interface} -setup {
    set parInst [ParameterPositional new U0 100]
} -body {
    set result [$parInst genSPICEString]
} -result 100 -cleanup {
    unset parInst result
}

###  ParameterPositionalNoCheck class tests 

test testParameterPositionalNoCheckClass-1 {test creation of ParameterPositionalNoCheck class instance} -setup {
    set parInst [ParameterPositionalNoCheck new U0 100]
} -body {
    $parInst configure -Value 1...1
    set result [$parInst configure -Value]
} -result 1...1 -cleanup {
    unset parInst result
}   

test testParameterPositionalNoCheckClass-2 {test creation of ParameterPositionalNoCheck class instance} -setup {
    set parInst [ParameterPositionalNoCheck new U0 1...1]
} -body {
    set result [$parInst genSPICEString]
} -result 1...1 -cleanup {
    unset parInst result
}  

###  ParameterEquation class tests 

test testParameterEquationClass-1 {test creation of ParameterEquation class instance and getValue interface} -setup {
    set parInst [ParameterEquation new U0T {temp*2.1+U0}]
} -body {
    set result [$parInst configure -Value]
} -result "temp*2.1+U0" -cleanup {
    unset parInst result
}
    
test testParameterEquationClass-2 {test creation of ParameterEquation class instance and genSPICEStr interface} -setup {
    set parInst [ParameterEquation new U0T {temp*2.1+U0}]
} -body {
    set result [$parInst genSPICEString]
} -result "u0t=\{temp*2.1+U0\}" -cleanup {
    unset parInst result
}
    
test testParameterEquationClass-3 {test creation of ParameterEquation class instance with empty value} -body {
    catch {ParameterEquation new U0T {}} errorStr
    return $errorStr
} -result "Parameter 'u0t' equation can't be empty" -cleanup {
    unset errorStr
}

###  ParameterPositionalEquation class tests 

test testParameterPositionalEquationClass-1 {test creation of ParameterPositionalEquation class instance and getValue interface} -setup {
    set parInst [ParameterPositionalEquation new U0T {temp*2.1+U0}]
} -body {
    set result [$parInst genSPICEString]
} -result "\{temp*2.1+U0\}" -cleanup {
    unset parInst result
}
    
###  Device class tests 

test testDeviceClass-1 {test creation of Device class instance and getName interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst configure -Name]
} -result m1 -cleanup {
    unset elemInst result
}

test testDeviceClass-2 {test creation of Device class instance and getPins interface} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst getPins]
} -result [dcreate d netd g netg s nets] -cleanup {
    unset elemInst result
}

test testDeviceClass-3 {test creation of Device class instance and handling duplicated pins names} -body {
    catch {set elemInst [Device new M1 {{d netg} {g netg} {s nets} {s netg}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]} errorStr
    return $errorStr
} -result "Pins list 'd g s s' has already contains pin with name 's'" -cleanup {
    unset errorStr
}

test testDeviceClass-4 {test creation of Device class instance and getParams interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst getParams]
} -result [dcreate vth0 0.7 u0 100 k1 1.5e-3] -cleanup {
    unset elemInst result
}

test testDeviceClass-5 {test creation of Device class instance and handling duplicated parameters names} -body {
    catch {set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3} {VTH0 0.2}}]} errorStr
    return $errorStr
} -result "Parameters list 'vth0 u0 k1 vth0' has already contains parameter with name 'vth0'" -cleanup {
    unset errorStr
}

test testDeviceClass-6 {test creation of Device class instance and handling wrong reference name} -body {
    catch {set elemInst [Device new 11 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]} errorStr
    return $errorStr
} -result "Reference name '11' is not a valid name" -cleanup {
    unset errorStr
}

test testDeviceClass-7 {test creation of Device class instance and handling wrong reference name} -body {
    catch {set elemInst [Device new M1. {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 5e-3}}]} errorStr
    return $errorStr
} -result "Reference name 'M1.' is not a valid name" -cleanup {
    unset errorStr
}

test testDeviceClass-8 {test creation of Device class instance and addParam interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    $elemInst addParam K2 -1.2e-4
    set result [$elemInst getParams]
} -result [dcreate vth0 0.7 u0 100 k1 1.5e-3 k2 -1.2e-4] -cleanup {
    unset elemInst result
}

test testDeviceClass-9 {test creation of Device class instance and deleteParam interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    $elemInst deleteParam vth0
    set result [$elemInst getParams]
} -result [dcreate u0 100 k1 1.5e-3] -cleanup {
    unset elemInst result
}

test testDeviceClass-10 {test creation of Device class instance and test string generation for SPICE netlist} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst genSPICEString]
} -result "m1 netd netg nets vth0=0.7 u0=100 k1=1.5e-3" -cleanup {
    unset elemInst result
}

test testDeviceClass-11 {test creation of Device class instance and test setPinNodeName} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
    $elemInst setPinNodeName g n123
} -body {
    set result [$elemInst getPins]
} -result [dcreate d netd g n123 s nets] -cleanup {
    unset elemInst result
}

test testDeviceClass-12 {test creation of Device class instance and test setPinNodeName with pin name not in the pin list of device} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst setPinNodeName p n123} errorStr
    return $errorStr
} -result "Pin with name 'p' was not found in device's 'm1' list of pins 'd g s'" -cleanup {
    unset elemInst errorStr
}

test testDeviceClass-13 {test creation of Device class instance and test setParamValue} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
    $elemInst setParamValue vth0 1.0
} -body {
    set result [$elemInst getParams]
} -result [dcreate vth0 1.0 u0 100 k1 1.5e-3] -cleanup {
    unset elemInst result
}

test testDeviceClass-14 {test creation of Device class instance and test setParamValue with parameter name not in the parameter list of device} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst setParamValue VTH01 1.0} errorStr
    return $errorStr
} -result "Parameter with name 'vth01' was not found in element's 'm1' list of parameters 'vth0 u0 k1'" -cleanup {
    unset elemInst errorStr
}

test testDeviceClass-15 {test creation of Device class instance and test deleteParam with parameter name not in the parameter list of device} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst deleteParam VTH01} errorStr
    return $errorStr
} -result "Parameter with name 'vth01' was not found in device's 'm1' list of parameters 'vth0 u0 k1'" -cleanup {
    unset elemInst errorStr
}

test testDeviceClass-16 {test creation of Device class instance and test string generation for SPICE netlist with positional parameter} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100 -pos} {K1 1.5e-3}}]
} -body {
    set result [$elemInst genSPICEString]
} -result "m1 netd netg nets vth0=0.7 100 k1=1.5e-3" -cleanup {
    unset elemInst result
}

test testDeviceClass-17 {test creation of Device class instance and test string generation for SPICE netlist with positional equation parameter} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 {u1+u2} -poseq} {K1 1.5e-3}}]
} -body {
    set result [$elemInst genSPICEString]
} -result "m1 netd netg nets vth0=0.7 {u1+u2} k1=1.5e-3" -cleanup {
    unset elemInst result
}

test testDeviceClass-18 {test creation of Device class instance and test string generation for SPICE netlist with equation parameter} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 {u1+u2} -eq} {K1 1.5e-3}}]
} -body {
    set result [$elemInst genSPICEString]
} -result "m1 netd netg nets vth0=0.7 u0={u1+u2} k1=1.5e-3" -cleanup {
    unset elemInst result
}

test testDeviceClass-19 {test creation of Device class instance and test string generation for SPICE netlist with unconnected pin} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s {}}} {{VTH0 0.7} {U0 100 -pos} {K1 1.5e-3}}]
} -body {
    catch {$elemInst genSPICEString} errorStr
    return $errorStr
} -result "Device 'm1' can't be netlisted because 's' pin is floating" -cleanup {
    unset errorStr
}

test testDeviceClass-20 {test creation of Device class instance and checkFloatingPins interface} -setup {
    set elemInst [Device new M1 {{d netd} {g {}} {s nets} {p {}}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst checkFloatingPins]
} -result [list g p] -cleanup {
    unset elemInst result
}

test testDeviceClass-21 {test creation of Device class instance and test setParamValue with multiple parameters} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    $elemInst setParamValue VTH0 1.0 U0 50
    $elemInst genSPICEString
} -result "m1 netd netg nets vth0=1.0 u0=50 k1=1.5e-3" -cleanup {
    unset elemInst
}

test testDeviceClass-22 {test creation of Device class instance and test setParamValue with multiple parameters} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst setParamValue VTH0 1.0 U0 50 K1} errorStr
    return $errorStr
} -result "Number of arguments to method 'setParamValue' must be even" -cleanup {
    unset elemInst errorStr
}

###  Model class tests 
    
test testModelClass-1 {test creation of Model class instance and getType interface} -setup {
    set modelInst [Model new MOD1 NMOS {{VTH0 0.7} {U0 100} {VTH1 1} {K1 1.5e-3}}]
} -body {
    set result [$modelInst configure -Type]
} -result nmos -cleanup {
    unset modelInst result
}

test testModelClass-2 {test creation of Model class instance and getParams interface} -setup {
    set modelInst [Model new MOD1 NMOS {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$modelInst getParams]
} -result [dcreate vth0 0.7 u0 100 k1 1.5e-3] -cleanup {
    unset modelInst result
}

test testModelClass-3 {test creation of Model class instance and genSPICEString interface} -setup {
    set modelInst [Model new MOD1 NMOS {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$modelInst genSPICEString]
} -result ".model mod1 nmos(vth0=0.7 u0=100 k1=1.5e-3)" -cleanup {
    unset modelInst result
}

test testModelClass-4 {test creation of Model class instance and genSPICEString interface} -setup {
    set modelInst [Model new MOD1 NMOS {{VTH0 0.7} {U0 v2*vb/2 -eq} {K1 1.5e-3}}]
} -body {
    set result [$modelInst genSPICEString]
} -result ".model mod1 nmos(vth0=0.7 u0=\{v2*vb/2\} k1=1.5e-3)" -cleanup {
    unset modelInst result
}

###  RawString class tests 
    
test testRawStringClass-1 {test creation of RawString class instance and genSPICEString interface} -setup {
    set raw [RawString new {arbitary string}]
} -body {
    set result [$raw genSPICEString]
} -result "arbitary string" -cleanup {
    unset raw result
}

test testRawStringClass-2 {test creation of RawString class instance with -name argument and getName interface} -setup {
    set raw [RawString new {arbitary string} -name raw1]
} -body {
    set result [$raw configure -Name]
} -result "raw1" -cleanup {
    unset raw result
}

#test testRawStringClass-3 {test creation of RawString class instance without -name argument and getName interface} -setup {
#    set raw [RawString new {arbitary string}]
#} -body {
#    set result [$raw getName]
#} -result $raw

###  Comment class tests 
    
test testCommentClass-1 {test creation of Comment class instance and genSPICEString interface} -setup {
    set raw [Comment new {comment string}]
} -body {
    set result [$raw genSPICEString]
} -result "*comment string" -cleanup {
    unset raw result
}

test testCommentClass-2 {test creation of Comment class instance and genSPICEString interface with multiline comment} -setup {
    set raw [Comment new {comment string1
comment string2
comment string3}]
} -body {
    set result [$raw genSPICEString]
} -result {*comment string1
*comment string2
*comment string3} -cleanup {
    unset raw result
}

###  Temp class tests 
    
test testTempClass-1 {test creation of Temp class instance and genSPICEString interface} -setup {
    set temp [Temp new 10]
} -body {
    set result [$temp genSPICEString]
} -result ".temp 10" -cleanup {
    unset temp result
}
    
test testTempClass-2 {test creation of Temp class instance and genSPICEString interface} -setup {
    set temp [Temp new temp -eq]
} -body {
    set result [$temp genSPICEString]
} -result ".temp \{temp\}" -cleanup {
    unset temp result
}
    
test testTempClass-3 {test creation of Temp class instance and getValue interface} -setup {
    set temp [Temp new temp -eq]
} -body {
    set result [$temp configure -Value]
} -result "temp" -cleanup {
    unset temp result
}
    
test testTempClass-4 {test creation of Temp class instance and setValue interface} -setup {
    set temp [Temp new temp -eq]
} -body {
    $temp configure -Value [list temp1 -eq]
    set result [$temp configure -Value]
} -result "temp1" -cleanup {
    unset temp result
}
    
test testTempClass-5 {test creation of Temp class instance and setValue interface with change of parameter type to equational} -setup {
    set temp [Temp new 10]
} -body {
    $temp configure -Value [list temp1 -eq]
    set result [$temp configure -Value]
} -result "temp1" -cleanup {
    unset temp result
}
    
###  Include class definition 

test testIncludeClass-1 {test creation of Include class instance and genSPICEString interface} -setup {
    set raw [Include new {./libs/mosfets/nmos1}]
} -body {
    set result [$raw genSPICEString]
} -result {.include ./libs/mosfets/nmos1} -cleanup {
    unset raw result
}
    
###  Library class definition 

test testLibraryClass-1 {test creation of Library class instance and genSPICEString interface} -setup {
    set raw [Library new ./libs/mosfets/nmos1 slow_corner]
} -body {
    set result [$raw genSPICEString]
} -result {.lib ./libs/mosfets/nmos1 slow_corner} -cleanup {
    unset raw result
}
    
test testLibraryClass-2 {test creation of Library class instance and getLibValue interface} -setup {
    set raw [Library new ./libs/mosfets/nmos1 slow_corner]
} -body {
    set result [$raw configure -LibValue]
} -result {slow_corner} -cleanup {
    unset raw result
}
    
###  Options class tests 

test testOptionsClass-1 {test creation of Options class instance and getParams interface} -setup {
    set elemInst [Options new {{abstol 1e-12} {noopiter -sw} {gmin 1e-12}}]
} -body {
    set result [$elemInst getParams]
} -result [dcreate abstol 1e-12 noopiter {} gmin 1e-12] -cleanup {
    unset elemInst result
}

test testOptionsClass-2 {test creation of Options class instance and genSPICEString interface} -setup {
    set elemInst [Options new {{abstol 1e-12} {noopiter -sw} {gmin 1e-12}}]
} -body {
    set result [$elemInst genSPICEString]
} -result ".options abstol=1e-12 noopiter gmin=1e-12" -cleanup {
    unset elemInst result
}

test testOptionsClass-3 {test creation of Options class instance and addParam interface} -setup {
    set elemInst [Options new {{abstol 1e-12} {noopiter -sw} {gmin 1e-12}}]
    $elemInst addParam vntol 1e-4
} -body {
    set result [$elemInst getParams]
} -result [dcreate abstol 1e-12 noopiter "" gmin 1e-12 vntol 1e-4] -cleanup {
    unset elemInst result
}

test testOptionsClass-4 {test creation of Options class instance and addParam interface with adding switch parameter} -setup {
    set elemInst [Options new {{abstol 1e-12} {vntol 1e-4} {gmin 1e-12}}]
    $elemInst addParam noopiter -sw
} -body {
    set result [$elemInst getParams]
} -result [dcreate abstol 1e-12 vntol 1e-4 gmin 1e-12  noopiter {}] -cleanup {
    unset elemInst result
}

test testOptionsClass-5 {test creation of Options class instance and deleteParam interface} -setup {
    set elemInst [Options new {{abstol 1e-12} {noopiter -sw} {gmin 1e-12}}]
    $elemInst deleteParam gmin
} -body {
    set result [$elemInst getParams]
} -result [dcreate abstol 1e-12 noopiter {}] -cleanup {
    unset elemInst result
}

test testOptionsClass-6 {test creation of Options class instance with switch parameter without -sw qualificator} -body {
    catch {Options new {{abstol 1e-12} {noopiter} {gmin 1e-12}}} errorStr
    return $errorStr
} -result "Value '' is not a valid value" -cleanup {
    unset errorStr
}

###  ParamStatement class tests 
    
test testParamStatementClass-1 {test creation of ParamStatement class instance and getParams interface} -setup {
    set elemInst [ParamStatement new {{U0T {rf+1} -eq} {vth0 10}}]
} -body {
    set result [$elemInst getParams]
} -result [dcreate u0t {rf+1} vth0 10] -cleanup {
    unset elemInst result
}

test testParamStatementClass-2 {test creation of ParamStatement class instance and genSPICEString interface} -setup {
    set elemInst [ParamStatement new {{U0T {rf+1} -eq} {vth0 10}}]
} -body {
    set result [$elemInst genSPICEString]
} -result ".param u0t=\{rf+1\} vth0=10" -cleanup {
    unset elemInst result
}

test testParamStatementClass-3 {test creation of ParamStatement class instance and addParam interface} -setup {
    set elemInst [ParamStatement new {{U0T {rf+1} -eq} {vth0 10}}]
    $elemInst addParam k1 1e-4
} -body {
    set result [$elemInst getParams]
} -result [dcreate u0t {rf+1} vth0 10 k1 1e-4] -cleanup {
    unset elemInst result
}

test testParamStatementClass-4 {test creation of ParamStatement class instance and addParam interface with adding equation parameter} -setup {
    set elemInst [ParamStatement new {{k1 1e-4} {vth0 10}}]
    $elemInst addParam U0T {rf+1} -eq
} -body {
    set result [$elemInst getParams]
} -result [dcreate k1 1e-4 vth0 10 u0t {rf+1}] -cleanup {
    unset elemInst result
}

test testParamStatementClass-5 {test creation of ParamStatement class instance with equation parameter without -eq qualificator} -body {
    catch {ParamStatement new {{U0T {rf+1}} {vth0 10}}} errorStr
    return $errorStr
} -result "Value 'rf+1' is not a valid value" -cleanup {
    unset errorStr
}

test testParamStatementClass-6 {test creation of ParamStatement class instance and setParamValue interface} -setup {
    set elemInst [ParamStatement new {{U0T {rf+1} -eq} {vth0 10}}]
} -body {
    $elemInst setParamValue u0t 2
    set result [$elemInst getParams]
} -result [dcreate u0t 2 vth0 10] -cleanup {
    unset elemInst result
}

###  Netlist class tests 
    
test testNetlistClass-1 {test creation of Netlist class instance with add interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    set result [$netlistInst genSPICEString]
} -result {r1 net1 net2 10
r2 net1 net2 {r1+5/10}
c1 net2 net3 1e-6
.param r1=1 r2=2
*some random comment
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string
v1 net1 net3 5} -cleanup {
    unset netlistInst result
}

test testNetlistClass-2 {test creation of Netlist class instance with del interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
    $netlistInst add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    $netlistInst del V1
    set result [$netlistInst genSPICEString]
} -result {r1 net1 net2 10
r2 net1 net2 {r1+5/10}
r5 net1 net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
c1 net2 net3 1e-6
.param r1=1 r2=2
*some random comment
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string} -cleanup {
    unset netlistInst result
} 

test testNetlistClass-3 {test creation of Netlist class instance with del interface with wrong name of element} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    catch {$netlistInst del r3} errorStr
    return $errorStr
} -result {Element with name 'r3' was not found in netlist's 'new_netlist' list of elements} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-4 {test creation of Netlist class instance and getElement interface} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    set elementObj [$netlistInst getElement r2]
    return [$elementObj configure -Name]
} -result r2 -cleanup {
    unset netlistInst elementObj
}

test testNetlistClass-5 {test creation of Netlist class instance with add element with same name as ones already added to netslit} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    catch {$netlistInst add [R new 1 net1 net2 -r 15]} errorStr
    return $errorStr
} -result {Netlist 'new_netlist' already contains element with name r1} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-6 {test creation of Netlist class instance and modifying value of netlist element} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    set resistor [$netlistInst getElement r1]
    $resistor setParamValue r 100
    return [$netlistInst genSPICEString]
} -result {r1 net1 net2 100
r2 net1 net2 {r1+5/10}
c1 net2 net3 1e-6
.param r1=1 r2=2
*some random comment
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string
v1 net1 net3 5} -cleanup {
    unset netlistInst resistor
}

    
###  Subcircuit class tests 

test testSubcircuitClass-1 {test creation of Subcircuit class instance with genSPICEString interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit genSPICEString]
    
} -result {.subckt rcnet plus minus r=100 c=1e-6
r1 net1 net2 {r}
c1 net2 net3 {c}
.ends} -cleanup {
    rename RCnet ""
    unset subcircuit result
}

test testSubcircuitClass-2 {test creation of Subcircuit class instance with getPins interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit getPins]
} -result {plus {} minus {}} -cleanup {
    rename RCnet ""
    unset subcircuit result
}
 
test testSubcircuitClass-3 {test creation of Subcircuit class instance with getParams interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit getParams]
} -result [dcreate r 100 c 1e-6] -cleanup {
    rename RCnet ""
    unset subcircuit result
}
 
test testSubcircuitClass-4 {test creation of Subcircuit class instance with forbidden element adding} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            my add [Include new {/fold1/fold2/file.lib} -name inc1]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    
} -body {
    catch {RCnet new} errorStr
    set result $errorStr
} -result {Include element can't be included in subcircuit} -cleanup {
    rename RCnet ""
    unset result errorStr
}

test testSubcircuitClass-5 {test creation of Subcircuit class instance with forbidden element Analysis} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            my add [Op new]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    
} -body {
    catch {RCnet new} errorStr
    set result $errorStr
} -result {Analysis element can't be included in subcircuit} -cleanup {
    rename RCnet ""
    unset result errorStr
}

test testSubcircuitClass-6 {test creation of Subcircuit class instance with genSPICEString interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            my add [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
            my add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit genSPICEString]
    
} -result {.subckt rcnet plus minus r=100 c=1e-6
r1 net1 net2 {r}
c1 net2 net3 {c}
r5 net1 net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
.ends} -cleanup {
    rename RCnet ""
    unset subcircuit result
}

###  Analysis class tests 
    
test testAnalysisClass-1 {test creation of Analysis class instance and getParams interface} -setup {
    set anInst [Analysis new dc {{srcnam v1 -posnocheck} {vstart 0 -pos} {vstop 5 -pos} {vincr 0.1 -pos}}]
} -body {
    set result [$anInst getParams]
} -result [dcreate srcnam v1 vstart 0 vstop 5 vincr 0.1] -cleanup {
    unset anInst result
}

test testAnalysisClass-2 {test creation of Analysis class instance and genSPICEString interface} -setup {
    set anInst [Analysis new dc {{srcnam v1 -posnocheck} {vstart 0 -pos} {vstop 5 -pos} {vincr 0.1 -pos}}]
} -body {
    set result [$anInst genSPICEString]
} -result ".dc v1 0 5 0.1" -cleanup {
    unset anInst result
}

test testAnalysisClass-3 {test creation of Analysis class instance and genSPICEString interface} -body {
    catch {set anInst [Analysis new dc1 {{srcnam v1 -posnocheck} {vstart 0 -pos} {vstop 5 -pos} {vincr 0.1 -pos}}]} errorStr
    return $errorStr
} -result "Type 'dc1' is not in supported list of analysis, should be one of 'ac dc tran op disto noise pz sens sp tf'" -cleanup {
    unset errorStr
}

test testAnalysisClass-4 {test creation of Analysis class instance and setParamValue interface} -setup {
    set anInst [Analysis new dc {{srcnam v1 -posnocheck} {vstart 0 -pos} {vstop 5 -pos} {vincr 0.1 -pos}}]
    $anInst setParamValue vstop 10
} -body {
    return [$anInst genSPICEString]   
} -result ".dc v1 0 10 0.1" -cleanup {
    unset anInst
}

test testAnalysisClass-5 {test creation of Analysis class instance and genSPICEString interface} -setup {
    set anInst [Analysis new dc {{srcnam v1 -posnocheck} {vstart 0 -pos} {vstop x**2+1 -poseq} {vincr 0.1 -pos}}]
} -body {
    set result [$anInst genSPICEString]
} -result ".dc v1 0 {x**2+1} 0.1" -cleanup {
    unset anInst result
}

test testAnalysisClass-6 {test creation of Analysis class instance and genSPICEString interface} -setup {
    set anInst [Analysis new tran {{tstep 1e-6 -pos} {tstop 10e-3 -pos} {uic -sw}}]
} -body {
    set result [$anInst genSPICEString]
} -result ".tran 1e-6 10e-3 uic" -cleanup {
    unset anInst result
}

###  RawFile class tests 

test testRawFileClass-1 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -Simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -Data]
} -body {
    set data [$dataObj getTracesCsv -all]
    return $data
} -result "v(v-sweep),v(in),v(out),i(v1)
0.0,0.0,0.0,0.0
1.0,1.0,0.6666666666666666,-0.0003333333333333334
2.0,2.0,1.3333333333333333,-0.0006666666666666668
3.0,3.0,2.0,-0.001
4.0,4.0,2.6666666666666665,-0.0013333333333333335
5.0,5.0,3.333333333333333,-0.001666666666666667
" -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-2 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -Simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -Data]
} -body {
    set data [$dataObj getTracesCsv -all -sep ,,]
    return $data
} -result "v(v-sweep),,v(in),,v(out),,i(v1)
0.0,,0.0,,0.0,,0.0
1.0,,1.0,,0.6666666666666666,,-0.0003333333333333334
2.0,,2.0,,1.3333333333333333,,-0.0006666666666666668
3.0,,3.0,,2.0,,-0.001
4.0,,4.0,,2.6666666666666665,,-0.0013333333333333335
5.0,,5.0,,3.333333333333333,,-0.001666666666666667
" -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-3 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -Simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -Data]
} -body {
    set data [$dataObj getTracesCsv -traces v(in) v(out)]
    return $data
} -result "v(in),v(out)
0.0,0.0
1.0,0.6666666666666666
2.0,1.3333333333333333
3.0,2.0
4.0,2.6666666666666665
5.0,3.333333333333333
" -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-4 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -Simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -Data]
} -body {
    catch {$dataObj getTracesCsv -traces v(in1) v(out)} errorStr
    return $errorStr
} -result "Trace with name 'v(in1)' was not found in raw file './voltage divider netlist.raw' list of traces" -cleanup {
    unset circuit errorStr simulator dataObj
}

test testRawFileClass-5 {test creation of RawFile class instance and getTracesCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -Simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -Data]
} -body {
    catch {$dataObj getTracesCsv} errorStr
    return $errorStr
} -result "Arguments '-all' or '-traces traceName1 traceName2 ...' must be provided to 'getTracesCsv' method" -cleanup {
    unset circuit errorStr simulator dataObj
}

###  Circuit class tests 

test testCircuitClass-1 {test creation of Circuit class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -Simulator $simulator
    $circuit runAndRead
} -body {
    set data [$circuit getDataCsv -traces v(in) v(out)]
    return $data
} -result "v(in),v(out)
0.0,0.0
1.0,0.6666666666666666
2.0,1.3333333333333333
3.0,2.0
4.0,2.6666666666666665
5.0,3.333333333333333
" -cleanup {
    unset circuit data simulator
}

foreach nameSpc $ngspiceNameSpc {
    namespace forget ${nameSpc}::*
}

cleanupTests
