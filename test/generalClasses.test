#  .|'''.|            ||                   ..|'''.|                   |''||''|         '||'
#  ||..  '  ... ...  ...    ....    ....  .|'     '    ....  .. ...      ||      ....   ||  
#   ''|||.   ||'  ||  ||  .|   '' .|...|| ||    .... .|...||  ||  ||     ||    .|   ''  ||  
# .     '||  ||    |  ||  ||      ||      '|.    ||  ||       ||  ||     ||    ||       ||  
# |'....|'   ||...'  .||.  '|...'  '|...'  ''|...'|   '|...' .||. ||.   .||.    '|...' .||. 
#            ||                                                                             
#           ''''                                                                            
# generalClasses.test
# Tests Ngspice simulators classes
#
# Copyright (c) 2024 George Yashin, georgtree@gmail.com
#
# MIT License
# See the file "LICENSE.txt" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

package require tcltest
namespace import ::tcltest::*
package require SpiceGenTcl
namespace import ::SpiceGenTcl::*
importNgspice

    
###  Pin class tests 

test testPinClass-1 {test creation of Pin class instance and getName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    set result [$pinInst configure -name]
} -result drain -cleanup {
    unset pinInst result
}

test testPinClass-2 {test creation of Pin class instance and getName interface} -setup {
    set pinInst [Pin new 23 netd]
} -body {
    set result [$pinInst configure -name]
} -result 23 -cleanup {
    unset pinInst result
}

test testPinClass-3 {test creation of Pin class instance and getNodeName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    set result [$pinInst configure -nodename]
} -result netd -cleanup {
    unset pinInst result
}

test testPinClass-4 {test creation of Pin class instance and genSPICEStr interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    set result [$pinInst genSPICEString]
} -result netd -cleanup {
    unset pinInst result
}

test testPinClass-5 {test creation of Pin class instance and checkFloating interface} -setup {
    set pinInst [Pin new drain {}]
} -body {
    set result [$pinInst checkFloating]
} -result true -cleanup {
    unset pinInst result
}

test testPinClass-6 {test creation of Pin class instance and check how genSPICEStr handling floating pin} -setup {
    set pinInst [Pin new drain {}]
} -body {
    catch {$pinInst genSPICEString} errorStr
    return $errorStr
} -result {Pin 'drain' is not connected to the node so can't be netlisted} -cleanup {
    unset pinInst errorStr
}

test testPinClass-10 {test creation of Pin class instance and handling empty string in the name} -body {
    catch {set pinInst [Pin new "" netd]} errorStr
    return $errorStr
} -result {Pin must have a name, empty string was provided} -cleanup {
    unset errorStr
}

test testPinClass-11 {test creation of Pin class instance and setNodeName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    $pinInst configure -nodename net1
    set result [$pinInst configure -nodename]
} -result net1 -cleanup {
    unset pinInst result
}
    
test testPinClass-12 {test creation of Pin class instance and setNodeName interface with wrong node name} -setup {
    set pinInst [Pin new drain netd]
} -body {
    catch {$pinInst configure -nodename 123net} errorStr
    return $errorStr
} -result {Node name '123net' is not a valid name} -cleanup {
    unset pinInst errorStr
}
    
test testPinClass-13 {test creation of Pin class instance and unsetNodeName interface} -setup {
    set pinInst [Pin new drain netd]
} -body {
    $pinInst unsetNodeName
    set result [$pinInst configure -nodename]
} -result {} -cleanup {
    unset pinInst result
}
    
test testPinClass-14 {test creation of Pin class instance and getName interface} -setup {
    set pinInst [Pin new drain_ netd_]
} -body {
    set result [$pinInst configure -name]
} -result drain_ -cleanup {
    unset pinInst result
}
    
###  Parameter class tests 

test testParameterClass-1 {test creation of Parameter class instance and getName interface} -setup {
    set parInst [Parameter new VTH 0.7]
} -body {
    set result [$parInst configure -name]
} -result vth -cleanup {
    unset parInst result
}

test testParameterClass-2 {test creation of Parameter class instance and getValue interface} -setup {
    set parInst [Parameter new VTH 0.7]
} -body {
    set result [$parInst configure -value]
} -result 0.7 -cleanup {
    unset parInst result
}

test testParameterClass-3 {test creation of Parameter class instance and getValue interface} -setup {
    set parInst [Parameter new VTH 0.007e+3]
} -body {
    set result [$parInst configure -value]
} -result 0.007e+3 -cleanup {
    unset parInst result
}

test testParameterClass-4 {test creation of Parameter class instance and handling wrong symbols in the name}  -body {
    catch {set parInst [Parameter new VT.H 0.7]} errorStr
    return $errorStr
} -result {Parameter name 'VT.H' is not a valid name} -cleanup {
    unset errorStr
}

test testParameterClass-5 {test creation of Parameter class instance and handling empty string in the name}  -body {
    catch {set parInst [Parameter new "" 0.7]} errorStr
    return $errorStr
} -result {Parameter must have a name, empty string was provided} -cleanup {
    unset errorStr
}

test testParameterClass-6 {test creation of Parameter class instance and handling wrong form of the value}  -body {
    catch {set parInst [Parameter new VTH 0.7e-]} errorStr
    return $errorStr
} -result {Value '0.7e-' is not a valid value} -cleanup {
    unset errorStr
}

test testParameterClass-7 {test creation of Parameter class instance and setValue interface} -setup {
    set parInst [Parameter new VTH 0.7]
    $parInst configure -value 1.0
} -body {
    set result [$parInst configure -value]
} -result 1.0 -cleanup {
    unset parInst result
}

test testParameterClass-8 {test creation of Parameter class instance and setValue interface with wrong value string} -setup {
    set parInst [Parameter new VTH 0.7]
} -body {
    catch {$parInst configure -value 1..0} errorStr
    return $errorStr
} -result {Value '1..0' is not a valid value} -cleanup {
    unset parInst errorStr
}

test testParameterClass-9 {test creation of Parameter class instance and getName interface} -setup {
    set parInst [Parameter new VTH 700u]
} -body {
    set result [$parInst configure -name]
} -result vth -cleanup {
    unset parInst result
}

test testParameterClass-10 {test creation of Parameter class instance and getName interface} -setup {
    set parInst [Parameter new VTH 700U]
} -body {
    set result [$parInst configure -name]
} -result vth -cleanup {
    unset parInst result
}

test testParameterClass-11 {test creation of Parameter class instance} -setup {
    set parInst [Parameter new GMIN 1.0T]
} -body {
    set result [$parInst configure -value]
} -result 1.0t -cleanup {
    unset parInst result
}

test testParameterClass-12 {test creation of Parameter class instance} -setup {
    set parInst [Parameter new GMIN 1.0meg]
} -body {
    set result [$parInst configure -value]
} -result 1.0meg -cleanup {
    unset parInst result
}

test testParameterClass-13 {test creation of Parameter class instance} -setup {
    set parInst [Parameter new GMIN 1e-6Meg]
} -body {
    set result [$parInst configure -value]
} -result 1e-6meg -cleanup {
    unset parInst result
}

test testParameterClass-14 {test creation of Parameter class instance and handling wrong form of the value}  -body {
    catch {set parInst [Parameter new VTH 70!0meg]} errorStr
    return $errorStr
} -result {Value '70!0meg' is not a valid value} -cleanup {
    unset errorStr
}

###  ParameterNode class tests 

test testParameterNodeClass-1 {test creation of ParameterNode class instance and getName interface} -setup {
    set parInst [ParameterNode new v(1) 0.7]
} -body {
    set result [$parInst genSPICEString]
} -result {v(1)=0.7} -cleanup {
    unset parInst result
}

###  ParameterNodeEquation class tests 

test testParameterNodeEquationClass-2 {test creation of ParameterNodeEquation class instance and getName interface} -setup {
    set parInst [ParameterNodeEquation new v(1) volt]
} -body {
    set result [$parInst genSPICEString]
} -result {v(1)={volt}} -cleanup {
    unset parInst result
}

###  ParameterNoCheck class tests 

test testParameterNoCheckClass-1 {test creation of ParameterNoCheck class instance} -setup {
    set parInst [ParameterNoCheck new VTH 0.7]
} -body {
    $parInst configure -value 1..0
    return [$parInst configure -value]
} -result 1..0 -cleanup {
    unset parInst
}    
    
###  ParameterDefault class tests 

test testParameterDefaultClass-1 {test creation of ParameterDefault class instance and getName interface} -setup {
    set parInst [ParameterDefault new U0 100 200]
} -body {
    set result [$parInst configure -name]
} -result u0 -cleanup {
    unset parInst result
}

test testParameterDefaultClass-2 {test creation of ParameterDefault class instance and getValue interface} -setup {
    set parInst [ParameterDefault new U0 100 200]
} -body {
    set result [$parInst configure -value]
} -result 100 -cleanup {
    unset parInst result
}

test testParameterDefaultClass-3 {test creation of ParameterDefault class instance and getDefValue interface} -setup {
    set parInst [ParameterDefault new U0 100 200]
} -body {
    set result [$parInst configure -defvalue]
} -result 200 -cleanup {
    unset parInst result
}

test testParameterDefaultClass-4 {test creation of ParameterDefault class instance and resetValue method} -setup {
    set parInst [ParameterDefault new U0 100 200]
    $parInst resetValue
} -body {
    set result [$parInst configure -value]
} -result 200 -cleanup {
    unset parInst result
}
    
###  ParameterSwitch class tests  

test testParameterSwitchClass-1 {test creation of ParameterSwitch class instance and getName interface} -setup {
    set parInst [ParameterSwitch new U0]
} -body {
    set result [$parInst configure -name]
} -result u0 -cleanup {
    unset parInst result
}

test testParameterSwitchClass-2 {test creation of ParameterSwitch class instance and genSPICEString interface} -setup {
    set parInst [ParameterSwitch new U0]
} -body {
    set result [$parInst genSPICEString]
} -result u0 -cleanup {
    unset parInst result
}
    
###  ParameterPositional class tests 

test testParameterPositionalClass-1 {test creation of ParameterPositional class instance and getName interface} -setup {
    set parInst [ParameterPositional new U0 100]
} -body {
    set result [$parInst configure -name]
} -result u0 -cleanup {
    unset parInst result
}

test testParameterPositionalClass-2 {test creation of ParameterPositional class instance and genSPICEString interface} -setup {
    set parInst [ParameterPositional new U0 100]
} -body {
    set result [$parInst genSPICEString]
} -result 100 -cleanup {
    unset parInst result
}

###  ParameterPositionalNoCheck class tests 

test testParameterPositionalNoCheckClass-1 {test creation of ParameterPositionalNoCheck class instance} -setup {
    set parInst [ParameterPositionalNoCheck new U0 100]
} -body {
    $parInst configure -value 1...1
    set result [$parInst configure -value]
} -result 1...1 -cleanup {
    unset parInst result
}   

test testParameterPositionalNoCheckClass-2 {test creation of ParameterPositionalNoCheck class instance} -setup {
    set parInst [ParameterPositionalNoCheck new U0 1...1]
} -body {
    set result [$parInst genSPICEString]
} -result 1...1 -cleanup {
    unset parInst result
}

test testParameterPositionalNoCheckClass-3 {test creation of ParameterPositionalNoCheck class instance} -body {
    catch {ParameterPositionalNoCheck new U0 ""} errorStr
    return $errorStr
} -result {Value '' is not a valid value} -cleanup {
    unset errorStr
} 

###  ParameterEquation class tests 

test testParameterEquationClass-1 {test creation of ParameterEquation class instance and getValue interface} -setup {
    set parInst [ParameterEquation new U0T {temp*2.1+U0}]
} -body {
    set result [$parInst configure -value]
} -result temp*2.1+U0 -cleanup {
    unset parInst result
}
    
test testParameterEquationClass-2 {test creation of ParameterEquation class instance and genSPICEStr interface} -setup {
    set parInst [ParameterEquation new U0T {temp*2.1+U0}]
} -body {
    set result [$parInst genSPICEString]
} -result {u0t={temp*2.1+U0}} -cleanup {
    unset parInst result
}
    
test testParameterEquationClass-3 {test creation of ParameterEquation class instance with empty value} -body {
    catch {ParameterEquation new U0T {}} errorStr
    return $errorStr
} -result {Parameter 'u0t' equation can't be empty} -cleanup {
    unset errorStr
}

###  ParameterPositionalEquation class tests 

test testParameterPositionalEquationClass-1 {test creation of ParameterPositionalEquation class instance and getValue interface} -setup {
    set parInst [ParameterPositionalEquation new U0T {temp*2.1+U0}]
} -body {
    set result [$parInst genSPICEString]
} -result {{temp*2.1+U0}} -cleanup {
    unset parInst result
}
    
###  Device class tests 

test testDeviceClass-1 {test creation of Device class instance and getName interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst configure -name]
} -result m1 -cleanup {
    unset elemInst result
}

test testDeviceClass-2 {test creation of Device class instance and getPins interface} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst getPins]
} -result {d netd g netg s nets} -cleanup {
    unset elemInst result
}

test testDeviceClass-3 {test creation of Device class instance and handling duplicated pins names} -body {
    catch {set elemInst [Device new M1 {{d netg} {g netg} {s nets} {s netg}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]} errorStr
    return $errorStr
} -result {Pins list 'd g s s' has already contains pin with name 's'} -cleanup {
    unset errorStr
}

test testDeviceClass-4 {test creation of Device class instance and getParams interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst getParams]
} -result {vth0 0.7 u0 100 k1 1.5e-3} -cleanup {
    unset elemInst result
}

test testDeviceClass-5 {test creation of Device class instance and handling duplicated parameters names} -body {
    catch {set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3} {VTH0 0.2}}]} errorStr
    return $errorStr
} -result {Parameters list 'vth0 u0 k1 vth0' has already contains parameter with name 'vth0'} -cleanup {
    unset errorStr
}

test testDeviceClass-6 {test creation of Device class instance and handling wrong reference name} -body {
    catch {set elemInst [Device new 11 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]} errorStr
    return $errorStr
} -result {Reference name '11' is not a valid name} -cleanup {
    unset errorStr
}

test testDeviceClass-7 {test creation of Device class instance and handling wrong reference name} -body {
    catch {set elemInst [Device new M1. {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 5e-3}}]} errorStr
    return $errorStr
} -result {Reference name 'M1.' is not a valid name} -cleanup {
    unset errorStr
}

test testDeviceClass-8 {test creation of Device class instance and addParam interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    $elemInst addParam K2 -1.2e-4
    set result [$elemInst getParams]
} -result {vth0 0.7 u0 100 k1 1.5e-3 k2 -1.2e-4} -cleanup {
    unset elemInst result
}

test testDeviceClass-9 {test creation of Device class instance and deleteParam interface} -setup {
    set elemInst [Device new M1 {{d netg} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    $elemInst deleteParam vth0
    set result [$elemInst getParams]
} -result {u0 100 k1 1.5e-3} -cleanup {
    unset elemInst result
}

test testDeviceClass-10 {test creation of Device class instance and test string generation for SPICE netlist} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {m1 netd netg nets vth0=0.7 u0=100 k1=1.5e-3} -cleanup {
    unset elemInst result
}

test testDeviceClass-11 {test creation of Device class instance and test setPinNodeName} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
    $elemInst setPinNodeName g n123
} -body {
    set result [$elemInst getPins]
} -result {d netd g n123 s nets} -cleanup {
    unset elemInst result
}

test testDeviceClass-12 {test creation of Device class instance and test setPinNodeName with pin name not in the pin list of device} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst setPinNodeName p n123} errorStr
    return $errorStr
} -result {Pin with name 'p' was not found in device's 'm1' list of pins 'd g s'} -cleanup {
    unset elemInst errorStr
}

test testDeviceClass-13 {test creation of Device class instance and test setParamValue} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
    $elemInst setParamValue vth0 1.0
} -body {
    set result [$elemInst getParams]
} -result {vth0 1.0 u0 100 k1 1.5e-3} -cleanup {
    unset elemInst result
}

test testDeviceClass-14 {test creation of Device class instance and test setParamValue with parameter name not in the parameter list of device} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst setParamValue VTH01 1.0} errorStr
    return $errorStr
} -result {Parameter with name 'vth01' was not found in element's 'm1' list of parameters 'vth0 u0 k1'} -cleanup {
    unset elemInst errorStr
}

test testDeviceClass-15 {test creation of Device class instance and test deleteParam with parameter name not in the parameter list of device} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst deleteParam VTH01} errorStr
    return $errorStr
} -result {Parameter with name 'vth01' was not found in device's 'm1' list of parameters 'vth0 u0 k1'} -cleanup {
    unset elemInst errorStr
}

test testDeviceClass-16 {test creation of Device class instance and test string generation for SPICE netlist with positional parameter} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100 -pos} {K1 1.5e-3}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {m1 netd netg nets vth0=0.7 100 k1=1.5e-3} -cleanup {
    unset elemInst result
}

test testDeviceClass-17 {test creation of Device class instance and test string generation for SPICE netlist with positional equation parameter} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 {u1+u2} -poseq} {K1 1.5e-3}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {m1 netd netg nets vth0=0.7 {u1+u2} k1=1.5e-3} -cleanup {
    unset elemInst result
}

test testDeviceClass-18 {test creation of Device class instance and test string generation for SPICE netlist with equation parameter} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 {u1+u2} -eq} {K1 1.5e-3}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {m1 netd netg nets vth0=0.7 u0={u1+u2} k1=1.5e-3} -cleanup {
    unset elemInst result
}

test testDeviceClass-19 {test creation of Device class instance and test string generation for SPICE netlist with unconnected pin} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s {}}} {{VTH0 0.7} {U0 100 -pos} {K1 1.5e-3}}]
} -body {
    catch {$elemInst genSPICEString} errorStr
    return $errorStr
} -result {Device 'm1' can't be netlisted because 's' pin is floating} -cleanup {
    unset errorStr
}

test testDeviceClass-20 {test creation of Device class instance and checkFloatingPins interface} -setup {
    set elemInst [Device new M1 {{d netd} {g {}} {s nets} {p {}}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$elemInst checkFloatingPins]
} -result {g p} -cleanup {
    unset elemInst result
}

test testDeviceClass-21 {test creation of Device class instance and test setParamValue with multiple parameters} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    $elemInst setParamValue VTH0 1.0 U0 50
    $elemInst genSPICEString
} -result {m1 netd netg nets vth0=1.0 u0=50 k1=1.5e-3} -cleanup {
    unset elemInst
}

test testDeviceClass-22 {test creation of Device class instance and test setParamValue with multiple parameters} -setup {
    set elemInst [Device new M1 {{d netd} {g netg} {s nets}} {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    catch {$elemInst setParamValue VTH0 1.0 U0 50 K1} errorStr
    return $errorStr
} -result {Number of arguments to method 'setParamValue' must be even} -cleanup {
    unset elemInst errorStr
}

###  Model class tests 
    
test testModelClass-1 {test creation of Model class instance and getType interface} -setup {
    set modelInst [Model new MOD1 NMOS {{VTH0 0.7} {U0 100} {VTH1 1} {K1 1.5e-3}}]
} -body {
    set result [$modelInst configure -type]
} -result nmos -cleanup {
    unset modelInst result
}

test testModelClass-2 {test creation of Model class instance and getParams interface} -setup {
    set modelInst [Model new MOD1 NMOS {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$modelInst getParams]
} -result {vth0 0.7 u0 100 k1 1.5e-3} -cleanup {
    unset modelInst result
}

test testModelClass-3 {test creation of Model class instance and genSPICEString interface} -setup {
    set modelInst [Model new MOD1 NMOS {{VTH0 0.7} {U0 100} {K1 1.5e-3}}]
} -body {
    set result [$modelInst genSPICEString]
} -result {.model mod1 nmos(vth0=0.7 u0=100 k1=1.5e-3)} -cleanup {
    unset modelInst result
}

test testModelClass-4 {test creation of Model class instance and genSPICEString interface} -setup {
    set modelInst [Model new MOD1 NMOS {{VTH0 0.7} {U0 v2*vb/2 -eq} {K1 1.5e-3}}]
} -body {
    set result [$modelInst genSPICEString]
} -result {.model mod1 nmos(vth0=0.7 u0={v2*vb/2} k1=1.5e-3)} -cleanup {
    unset modelInst result
}

###  RawString class tests 
    
test testRawStringClass-1 {test creation of RawString class instance and genSPICEString interface} -setup {
    set raw [RawString new {arbitary string}]
} -body {
    set result [$raw genSPICEString]
} -result {arbitary string} -cleanup {
    unset raw result
}

test testRawStringClass-2 {test creation of RawString class instance with -name argument and getName interface} -setup {
    set raw [RawString new {arbitary string} -name raw1]
} -body {
    set result [$raw configure -name]
} -result raw1 -cleanup {
    unset raw result
}

#test testRawStringClass-3 {test creation of RawString class instance without -name argument and getName interface} -setup {
#    set raw [RawString new {arbitary string}]
#} -body {
#    set result [$raw getName]
#} -result $raw

###  Comment class tests 
    
test testCommentClass-1 {test creation of Comment class instance and genSPICEString interface} -setup {
    set raw [Comment new {comment string}]
} -body {
    set result [$raw genSPICEString]
} -result {*comment string} -cleanup {
    unset raw result
}

test testCommentClass-2 {test creation of Comment class instance and genSPICEString interface with multiline comment} -setup {
    set raw [Comment new {comment string1
comment string2
comment string3}]
} -body {
    set result [$raw genSPICEString]
} -result {*comment string1
*comment string2
*comment string3} -cleanup {
    unset raw result
}

###  Temp class tests 
    
test testTempClass-1 {test creation of Temp class instance and genSPICEString interface} -setup {
    set temp [Temp new 10]
} -body {
    set result [$temp genSPICEString]
} -result {.temp 10} -cleanup {
    unset temp result
}
    
test testTempClass-2 {test creation of Temp class instance and genSPICEString interface} -setup {
    set temp [Temp new temp -eq]
} -body {
    set result [$temp genSPICEString]
} -result {.temp {temp}} -cleanup {
    unset temp result
}
    
test testTempClass-3 {test creation of Temp class instance and getValue interface} -setup {
    set temp [Temp new temp -eq]
} -body {
    set result [$temp configure -value]
} -result temp -cleanup {
    unset temp result
}
    
test testTempClass-4 {test creation of Temp class instance and setValue interface} -setup {
    set temp [Temp new temp -eq]
} -body {
    $temp configure -value [list temp1 -eq]
    set result [$temp configure -value]
} -result temp1 -cleanup {
    unset temp result
}
    
test testTempClass-5 {test creation of Temp class instance and setValue interface with change of parameter type to equational} -setup {
    set temp [Temp new 10]
} -body {
    $temp configure -value [list temp1 -eq]
    set result [$temp configure -value]
} -result temp1 -cleanup {
    unset temp result
}

test testTempClass-6 {test creation of Temp class instance and genSPICEString interface} -body {
    set temp [Temp new 10]
    catch {$temp configure -value [list temp1 -e2q]} errorStr
    return $errorStr
} -result {Wrong value '-e2q' of qualifier} -cleanup {
    unset errorStr temp
}
    
###  Include class definition 

test testIncludeClass-1 {test creation of Include class instance and genSPICEString interface} -setup {
    set raw [Include new {./libs/mosfets/nmos1}]
} -body {
    set result [$raw genSPICEString]
} -result {.include ./libs/mosfets/nmos1} -cleanup {
    unset raw result
}
    
###  Library class definition 

test testLibraryClass-1 {test creation of Library class instance and genSPICEString interface} -setup {
    set raw [Library new ./libs/mosfets/nmos1 slow_corner]
} -body {
    set result [$raw genSPICEString]
} -result {.lib ./libs/mosfets/nmos1 slow_corner} -cleanup {
    unset raw result
}
    
test testLibraryClass-2 {test creation of Library class instance and getLibValue interface} -setup {
    set raw [Library new ./libs/mosfets/nmos1 slow_corner]
} -body {
    set result [$raw configure -libvalue]
} -result {slow_corner} -cleanup {
    unset raw result
}
    
###  Options class tests 

test testOptionsClass-1 {test creation of Options class instance and getParams interface} -setup {
    set elemInst [Options new {{abstol 1e-12} {noopiter -sw} {gmin 1e-12}}]
} -body {
    set result [$elemInst getParams]
} -result {abstol 1e-12 noopiter {} gmin 1e-12} -cleanup {
    unset elemInst result
}

test testOptionsClass-2 {test creation of Options class instance and genSPICEString interface} -setup {
    set elemInst [Options new {{abstol 1e-12} {noopiter -sw} {gmin 1e-12}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {.options abstol=1e-12 noopiter gmin=1e-12} -cleanup {
    unset elemInst result
}

test testOptionsClass-3 {test creation of Options class instance and addParam interface} -setup {
    set elemInst [Options new {{abstol 1e-12} {noopiter -sw} {gmin 1e-12}}]
    $elemInst addParam vntol 1e-4
} -body {
    set result [$elemInst genSPICEString]
} -result {.options abstol=1e-12 noopiter gmin=1e-12 vntol=1e-4} -cleanup {
    unset elemInst result
}

test testOptionsClass-4 {test creation of Options class instance and addParam interface with adding switch parameter} -setup {
    set elemInst [Options new {{abstol 1e-12} {vntol 1e-4} {gmin gminval -eq}}]
    $elemInst addParam noopiter -sw
} -body {
    set result [$elemInst genSPICEString]
} -result {.options abstol=1e-12 vntol=1e-4 gmin={gminval} noopiter} -cleanup {
    unset elemInst result
}

test testOptionsClass-5 {test creation of Options class instance and deleteParam interface} -setup {
    set elemInst [Options new {{abstol 1e-12} {noopiter -sw} {gmin 1e-12}}]
    $elemInst deleteParam gmin
} -body {
    set result [$elemInst genSPICEString]
} -result {.options abstol=1e-12 noopiter} -cleanup {
    unset elemInst result
}

test testOptionsClass-6 {test creation of Options class instance with switch parameter without -sw qualificator} -body {
    catch {Options new {{abstol 1e-12} {noopiter} {gmin 1e-12}}} errorStr
    return $errorStr
} -result {Value '' is not a valid value} -cleanup {
    unset errorStr
}

###  ParamStatement class tests 
    
test testParamStatementClass-1 {test creation of ParamStatement class instance and genSPICEString interface} -setup {
    set elemInst [ParamStatement new {{U0T rf+1 -eq} {vth0 10}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {.param u0t={rf+1} vth0=10} -cleanup {
    unset elemInst result
}

test testParamStatementClass-2 {test creation of ParamStatement class instance and genSPICEString interface} -setup {
    set elemInst [ParamStatement new {{U0T rf+1 -eq} {vth0 10}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {.param u0t={rf+1} vth0=10} -cleanup {
    unset elemInst result
}

test testParamStatementClass-3 {test creation of ParamStatement class instance and addParam interface} -setup {
    set elemInst [ParamStatement new {{U0T rf+1 -eq} {vth0 10}}]
    $elemInst addParam k1 1e-4
} -body {
    set result [$elemInst genSPICEString]
} -result {.param u0t={rf+1} vth0=10 k1=1e-4} -cleanup {
    unset elemInst result
}

test testParamStatementClass-4 {test creation of ParamStatement class instance and addParam interface with adding equation parameter} -setup {
    set elemInst [ParamStatement new {{k1 1e-4} {vth0 10}}]
    $elemInst addParam U0T {rf+1} -eq
} -body {
    set result [$elemInst getParams]
} -result {k1 1e-4 vth0 10 u0t rf+1} -cleanup {
    unset elemInst result
}

test testParamStatementClass-5 {test creation of ParamStatement class instance with equation parameter without -eq qualificator} -body {
    catch {ParamStatement new {{U0T rf+1} {vth0 10}}} errorStr
    return $errorStr
} -result {Value 'rf+1' is not a valid value} -cleanup {
    unset errorStr
}

test testParamStatementClass-6 {test creation of ParamStatement class instance and setParamValue interface} -setup {
    set elemInst [ParamStatement new {{U0T rf+1 -eq} {vth0 10}}]
} -body {
    $elemInst setParamValue u0t 2
    set result [$elemInst getParams]
} -result {u0t 2 vth0 10} -cleanup {
    unset elemInst result
}

###  Ic class tests 
    
test testIcClass-1 {test creation of Ic class instance and getParams interface} -setup {
    set elemInst [Ic new {{v(a) v1 -eq} {v(b) 10}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {.ic v(a)={v1} v(b)=10} -cleanup {
    unset elemInst result
}

test testIcClass-2 {test creation of Ic class instance and getParams interface} -setup {
    set elemInst [Ic new {{a v1 -eq} {b 10}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {.ic a={v1} b=10} -cleanup {
    unset elemInst result
}

###  Nodeset class tests 
    
test testNodesetClass-1 {test creation of Nodeset class instance and getParams interface} -setup {
    set elemInst [Nodeset new {{v(a) v1 -eq} {v(b) 10}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {.nodeset v(a)={v1} v(b)=10} -cleanup {
    unset elemInst result
}

test testNodesetClass-2 {test creation of Nodeset class instance and getParams interface} -setup {
    set elemInst [Nodeset new {{a v1 -eq} {b 10}}]
} -body {
    set result [$elemInst genSPICEString]
} -result {.nodeset a={v1} b=10} -cleanup {
    unset elemInst result
}

###  Global class tests 

test testGlobalClass-1 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1 gnd2 g}]
} -body {
    set result [$elemInst genSPICEString]
} -result {.global gnd1 gnd2 g} -cleanup {
    unset elemInst result
}

test testGlobalClass-2 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1 gnd2 g}]
} -body {
    $elemInst addNets {gnd5 gnd6}
    set result [$elemInst genSPICEString]
} -result {.global gnd1 gnd2 g gnd5 gnd6} -cleanup {
    unset elemInst result
}

test testGlobalClass-3 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1 gnd2 g}]
} -body {
    $elemInst deleteNet {gnd2}
    set result [$elemInst genSPICEString]
} -result {.global gnd1 g} -cleanup {
    unset elemInst result
}

test testGlobalClass-4 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1 gnd2 g} -name glob1]
} -body {
    catch {$elemInst addNets {gnd3 gnd2}} errorStr
    return $errorStr
} -result {Net with name 'gnd2' is already attached to the object 'glob1'} -cleanup {
    unset elemInst errorStr
}

test testGlobalClass-5 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1 gnd2 g}]
} -body {
    catch {$elemInst addNets {gnd3 {}}} errorStr
    return $errorStr
} -result {Net name couldn't be empty} -cleanup {
    unset elemInst errorStr
}

test testGlobalClass-6 {test creation of Global class instance} -setup {
    set elemInst [Global new {gnd1} -name glob1]
} -body {
    $elemInst deleteNet gnd1
    catch {$elemInst deleteNet gnd2} errorStr
    return $errorStr
} -result {Global statement 'glob1' doesn't have attached net with name 'gnd2'} -cleanup {
    unset elemInst errorStr
}

###  Netlist class tests 
    
test testNetlistClass-1 {test creation of Netlist class instance with add interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    set result [$netlistInst genSPICEString]
} -result {r1 net1 net2 10
r2 net1 net2 {r1+5/10}
c1 net2 net3 1e-6
.param r1=1 r2=2
*some random comment
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string
v1 net1 net3 5} -cleanup {
    unset netlistInst result
}

test testNetlistClass-2 {test creation of Netlist class instance with del interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10] [R new 2 net1 net2 -r {{r1+5/10} -eq}]\
            [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
    $netlistInst add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    $netlistInst del V1
    set result [$netlistInst genSPICEString]
} -result {r1 net1 net2 10
r2 net1 net2 {r1+5/10}
r5 net1 net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
c1 net2 net3 1e-6
.param r1=1 r2=2
*some random comment
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string} -cleanup {
    unset netlistInst result
} 

test testNetlistClass-3 {test creation of Netlist class instance with del interface with wrong name of element} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    catch {$netlistInst del r3} errorStr
    return $errorStr
} -result {Element with name 'r3' was not found in netlist's 'new_netlist' list of elements} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-4 {test creation of Netlist class instance and getElement interface} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    set elementObj [$netlistInst getElement r2]
    return [$elementObj configure -name]
} -result r2 -cleanup {
    unset netlistInst elementObj
}

test testNetlistClass-5 {test creation of Netlist class instance with add element with same name as ones already added to netslit} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    catch {$netlistInst add [R new 1 net1 net2 -r 15]} errorStr
    return $errorStr
} -result {Netlist 'new_netlist' already contains element with name r1} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-6 {test creation of Netlist class instance and modifying value of netlist element} -setup {
    set netlistInst [Netlist new new_netlist]
    $netlistInst add [R new 1 net1 net2 -r 10]
    $netlistInst add [R new 2 net1 net2 -r {{r1+5/10} -eq}]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    set resistor [$netlistInst getElement r1]
    $resistor setParamValue r 100
    return [$netlistInst genSPICEString]
} -result {r1 net1 net2 100
r2 net1 net2 {r1+5/10}
c1 net2 net3 1e-6
.param r1=1 r2=2
*some random comment
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string
v1 net1 net3 5} -cleanup {
    unset netlistInst resistor
}

test testNetlistClass-7 {test creation of Netlist class instance with add element with same name as ones already added to netslit} -setup {
    set netlistInst [Netlist new new_netlist]
} -body {
    catch {$netlistInst add [R new 1 net1 net2 -r 10] [R new 1 net1 net2 -r 15]} errorStr
    return $errorStr
} -result {Netlist 'new_netlist' already contains element with name r1} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-8 {test creation of Netlist class instance with del interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10] [R new 2 net1 net2 -r {{r1+5/10} -eq}]\
            [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
    $netlistInst add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    $netlistInst del V1 com1
    set result [$netlistInst genSPICEString]
} -result {r1 net1 net2 10
r2 net1 net2 {r1+5/10}
r5 net1 net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
c1 net2 net3 1e-6
.param r1=1 r2=2
.include /fold1/fold2/file.lib
.lib /fold1/fold2/file.lib fast
*comment in form of raw string} -cleanup {
    unset netlistInst result
}

test testNetlistClass-9 {test creation of Netlist class instance with del interface and genSPICEString interface} -setup {
    set netlistInst [Netlist new newNetlist]
    $netlistInst add [R new 1 net1 net2 -r 10] [R new 2 net1 net2 -r {{r1+5/10} -eq}]\
            [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
    $netlistInst add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
    $netlistInst add [C new 1 net2 net3 -c 1e-6]
    $netlistInst add [ParamStatement new {{r1 1} {r2 2}} -name ps1]
    $netlistInst add [Comment new {some random comment} -name com1]
    $netlistInst add [Include new {/fold1/fold2/file.lib} -name inc1]
    $netlistInst add [Library new {/fold1/fold2/file.lib} fast -name lib1]
    $netlistInst add [RawString new {*comment in form of raw string} -name raw1]
    $netlistInst add [Vdc new 1 net1 net3 -dc 5]
} -body {
    catch {$netlistInst del V1 com1 V1} errorStr
    return $errorStr
} -result {Element with name 'v1' was not found in netlist's 'newnetlist' list of elements} -cleanup {
    unset netlistInst errorStr
}

test testNetlistClass-10 {test creation of Netlist class instance with del interface} -setup {
    set netlistInst [Netlist new newNetlist]
} -body {
    catch {$netlistInst del V1} errorStr
    return $errorStr
} -result {Netlist 'newnetlist' doesn't have attached elements} -cleanup {
    unset netlistInst errorStr
}
    
###  Subcircuit class tests 

test testSubcircuitClass-1 {test creation of Subcircuit class instance with genSPICEString interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}] [C new 1 net2 net3 -c {c -eq}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit genSPICEString]
    
} -result {.subckt rcnet plus minus r=100 c=1e-6
r1 net1 net2 {r}
c1 net2 net3 {c}
.ends rcnet} -cleanup {
    rename RCnet ""
    unset subcircuit result
}

test testSubcircuitClass-2 {test creation of Subcircuit class instance with getPins interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit getPins]
} -result {plus {} minus {}} -cleanup {
    rename RCnet ""
    unset subcircuit result
}
 
test testSubcircuitClass-3 {test creation of Subcircuit class instance with getParams interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit getParams]
} -result {r 100 c 1e-6} -cleanup {
    rename RCnet ""
    unset subcircuit result
}
 
test testSubcircuitClass-4 {test creation of Subcircuit class instance with forbidden element adding} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            my add [Include new {/fold1/fold2/file.lib} -name inc1]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    
} -body {
    catch {RCnet new} errorStr
    set result $errorStr
} -result {::SpiceGenTcl::Include element can't be included in subcircuit} -cleanup {
    rename RCnet ""
    unset result errorStr
}

test testSubcircuitClass-5 {test creation of Subcircuit class instance with forbidden element Analysis} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            my add [Op new]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    
} -body {
    catch {RCnet new} errorStr
    set result $errorStr
} -result {Analysis element can't be included in subcircuit} -cleanup {
    rename RCnet ""
    unset result errorStr
}

test testSubcircuitClass-6 {test creation of Subcircuit class instance with genSPICEString interface} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 net2 -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            my add [R new 5 net1 net2 -model res_sem -l 10e-6 -w 100e-6]
            my add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit genSPICEString]
    
} -result {.subckt rcnet plus minus r=100 c=1e-6
r1 net1 net2 {r}
c1 net2 net3 {c}
r5 net1 net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
.ends rcnet} -cleanup {
    rename RCnet ""
    unset subcircuit result
}

test testSubcircuitClass-7 {test creation of Subcircuit class instance with nested subcircuit} -setup {
    oo::class create RCnet {
        superclass Subcircuit
        constructor {} {
            # define external pins of subcircuit
            set pins {plus minus}
            # define input parameters of subcircuit
            set params {{r 100} {c 1e-6}}
            # add elements to subcircuit definition
            my add [R new 1 net1 plus -r {r -eq}]
            my add [C new 1 net2 net3 -c {c -eq}]
            my add [R new 5 minus net2 -model res_sem -l 10e-6 -w 100e-6]
            my add [RModel new rsem1mod -tc1 0.1 -tc2 0.4]

            oo::class create RCnetNest {
                superclass Subcircuit
                constructor {} {
                    set pins {plus minus}
                    set params {{r 100} {c 1e-6}}
                    my add [R new 1 net1 plus -r {r -eq}]
                    my add [C new 1 net2 net3 -c {c -eq}]
                    next rcnetnest $pins $params
                }
            }
            set subcircuitNest [RCnetNest new]
            my add $subcircuitNest
            my add [SubcircuitInstanceAuto new $subcircuitNest 2 {net1 net2} -r 1 -c {cpar -eq}]
            # pass name, list of pins and list of parameters to Subcircuit constructor
            next rcnet $pins $params
        }
    }
    set subcircuit [RCnet new]
} -body {
    set result [$subcircuit genSPICEString]
    
} -result {.subckt rcnet plus minus r=100 c=1e-6
r1 net1 plus {r}
c1 net2 net3 {c}
r5 minus net2 res_sem l=10e-6 w=100e-6
.model rsem1mod r(tc1=0.1 tc2=0.4)
.subckt rcnetnest plus minus r=100 c=1e-6
r1 net1 plus {r}
c1 net2 net3 {c}
.ends rcnetnest
x2 net1 net2 rcnetnest r=1 c={cpar}
.ends rcnet} -cleanup {
    rename RCnet ""
    unset subcircuit result
}

###  Analysis class tests 
    
test testAnalysisClass-1 {test creation of Analysis class instance and getParams interface} -setup {
    set anInst [Analysis new dc {{srcnam v1 -posnocheck} {vstart 0 -pos} {vstop 5 -pos} {vincr 0.1 -pos}}]
} -body {
    set result [$anInst getParams]
} -result {srcnam v1 vstart 0 vstop 5 vincr 0.1} -cleanup {
    unset anInst result
}

test testAnalysisClass-2 {test creation of Analysis class instance and genSPICEString interface} -setup {
    set anInst [Analysis new dc {{srcnam v1 -posnocheck} {vstart 0 -pos} {vstop 5 -pos} {vincr 0.1 -pos}}]
} -body {
    set result [$anInst genSPICEString]
} -result {.dc v1 0 5 0.1} -cleanup {
    unset anInst result
}

test testAnalysisClass-3 {test creation of Analysis class instance and genSPICEString interface} -body {
    catch {set anInst [Analysis new dc1 {{srcnam v1 -posnocheck} {vstart 0 -pos} {vstop 5 -pos} {vincr 0.1 -pos}}]} errorStr
    return $errorStr
} -result {Type 'dc1' is not in supported list of analysis, should be one of 'ac dc tran op disto noise pz sens sp tf'} -cleanup {
    unset errorStr
}

test testAnalysisClass-4 {test creation of Analysis class instance and setParamValue interface} -setup {
    set anInst [Analysis new dc {{srcnam v1 -posnocheck} {vstart 0 -pos} {vstop 5 -pos} {vincr 0.1 -pos}}]
    $anInst setParamValue vstop 10
} -body {
    return [$anInst genSPICEString]   
} -result {.dc v1 0 10 0.1} -cleanup {
    unset anInst
}

test testAnalysisClass-5 {test creation of Analysis class instance and genSPICEString interface} -setup {
    set anInst [Analysis new dc {{srcnam v1 -posnocheck} {vstart 0 -pos} {vstop x**2+1 -poseq} {vincr 0.1 -pos}}]
} -body {
    set result [$anInst genSPICEString]
} -result {.dc v1 0 {x**2+1} 0.1} -cleanup {
    unset anInst result
}

test testAnalysisClass-6 {test creation of Analysis class instance and genSPICEString interface} -setup {
    set anInst [Analysis new tran {{tstep 1e-6 -pos} {tstop 10e-3 -pos} {uic -sw}}]
} -body {
    set result [$anInst genSPICEString]
} -result {.tran 1e-6 10e-3 uic} -cleanup {
    unset anInst result
}

###  RawFile class tests 

test testRawFileClass-1 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    set data [$dataObj getTracesCsv -all]
    return $data
} -result {v(v-sweep),v(in),v(out),i(v1)
0.0,0.0,0.0,0.0
1.0,1.0,0.6666666666666666,-0.0003333333333333334
2.0,2.0,1.3333333333333333,-0.0006666666666666668
3.0,3.0,2.0,-0.001
4.0,4.0,2.6666666666666665,-0.0013333333333333335
5.0,5.0,3.333333333333333,-0.001666666666666667
} -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-2 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    set data [$dataObj getTracesCsv -all -sep ,,]
    return $data
} -result {v(v-sweep),,v(in),,v(out),,i(v1)
0.0,,0.0,,0.0,,0.0
1.0,,1.0,,0.6666666666666666,,-0.0003333333333333334
2.0,,2.0,,1.3333333333333333,,-0.0006666666666666668
3.0,,3.0,,2.0,,-0.001
4.0,,4.0,,2.6666666666666665,,-0.0013333333333333335
5.0,,5.0,,3.333333333333333,,-0.001666666666666667
} -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-3 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    set data [$dataObj getTracesCsv -traces v(in) v(out)]
    return $data
} -result {v(in),v(out)
0.0,0.0
1.0,0.6666666666666666
2.0,1.3333333333333333
3.0,2.0
4.0,2.6666666666666665
5.0,3.333333333333333
} -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-4 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    catch {$dataObj getTracesCsv -traces v(in1) v(out)} errorStr
    return $errorStr
} -result {Trace with name 'v(in1)' was not found in raw file './voltage divider netlist.raw' list of traces} -cleanup {
    unset circuit errorStr simulator dataObj
}

test testRawFileClass-5 {test creation of RawFile class instance and getTracesCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    catch {$dataObj getTracesCsv} errorStr
    return $errorStr
} -result {Arguments '-all' or '-traces traceName1 traceName2 ...' must be provided to 'getTracesCsv' method} -cleanup {
    unset circuit errorStr simulator dataObj
}

test testRawFileClass-6 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    set data [$dataObj getVoltagesNames]
    return $data
} -result {v(v-sweep) v(in) v(out)} -cleanup {
    unset circuit data simulator dataObj
}

test testRawFileClass-6 {test creation of RawFile class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
    set dataObj [$circuit configure -data]
} -body {
    set data [$dataObj getCurrentsNames]
    return $data
} -result i(v1) -cleanup {
    unset circuit data simulator dataObj
}

###  Circuit class tests 

test testCircuitClass-1 {test creation of Circuit class instance and getDataCsv interface} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3] [R new 2 out 0 -r 2e3] 
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
    set simulator [Batch new {batch1}]
    $circuit configure -simulator $simulator
    $circuit runAndRead
} -body {
    set data [$circuit getDataCsv -traces v(in) v(out)]
    return $data
} -result {v(in),v(out)
0.0,0.0
1.0,0.6666666666666666
2.0,1.3333333333333333
3.0,2.0
4.0,2.6666666666666665
5.0,3.333333333333333
} -cleanup {
    unset circuit data simulator
}

test testCircuitClass-2 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
} -body {
    catch {$circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]} errorStr
    return $errorStr
} -result {Netlist 'voltage divider netlist' already contains Analysis element} -cleanup {
    unset circuit errorStr
}

test testCircuitClass-3 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
} -body {
    catch {$circuit add [R new 1 out 0 -r 2e3]} errorStr
    return $errorStr
} -result {Netlist 'voltage divider netlist' already contains element with name r1} -cleanup {
    unset circuit errorStr
}

test testCircuitClass-4 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
} -body {
    catch {$circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1] [Dc new -src v1 -start 0 -stop 5 -incr 1]} errorStr
    return $errorStr
} -result {Netlist 'voltage divider netlist' already contains Analysis element} -cleanup {
    unset circuit errorStr
}

test testCircuitClass-5 {test creation of Circuit class instance} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3] [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1]
} -body {
    $circuit del R2 r1
    return [$circuit genSPICEString]
} -result {voltage divider netlist
v1 in 0 1
.dc v1 0 5 1} -cleanup {
    unset circuit
}

test testCircuitClass-4 {test creation of Circuit class instance, add Anslysis, remove it and then add again} -setup {
    set circuit [Circuit new {voltage divider netlist}]
    $circuit add [Vdc new 1 in 0 -dc 1]
    $circuit add [R new 1 in out -r 1e3]
    $circuit add [R new 2 out 0 -r 2e3]
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1 -name dc1]
    $circuit del dc1
} -body {
    $circuit add [Dc new -src v1 -start 0 -stop 5 -incr 1 -name dc1]
    return [$circuit genSPICEString]
} -result {voltage divider netlist
v1 in 0 1
r1 in out 1e3
r2 out 0 2e3
.dc v1 0 5 1} -cleanup {
    unset circuit
}

forgetNgspice

cleanupTests
