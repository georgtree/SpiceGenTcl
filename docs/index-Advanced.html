<!DOCTYPE html><html><head><meta charset="utf-8"/>
<title>Tcl SpiceGenTcl package</title>
<link rel='stylesheet' type='text/css' href='assets/ruff-min.css' />
<script type='text/javascript' src='assets/ruff-min.js'></script>
</head>
<body>
<div class='ruff-layout'>
<header class='ruff-layout-header ruff-hd'>
<a style='text-decoration:none;' href='index.html'>Tcl SpiceGenTcl package (v0.54)</a>


            <div id="ruffButtonBar">
            <button id="ruffNavMove" onclick="ruffMoveNavPane()"></button>
            <button id="ruffToggleTheme" onclick="ruffNextTheme()"></button>
            </div>
        </header><main class='ruff-layout-main ruff-bd'><h1 class='ruff'><a name='Advanced'></a>Advanced<span class='ruff-uplink'><a href='#top'>Top</a>, <a href='index.html'>Main</a>, <a href='index-docindex.html#'>Index</a></span></h1>
<div style='clear:both;'></div>
<p class='ruff'>This section provides advanced examples from the <code>examples</code> folder in the root directory of <em>SpiceGenTcl</em>. Rather than focusing on basic operations, we highlight advanced use cases that showcase the full capabilities of both the package and the Tcl language. List of availible examples:</p>
<ul class='ruff'>
<li><a href="index-Advanced.html#::Advanced-Monte-Carlo simulation" title="Monte-Carlo simulation" >Monte-Carlo simulation</a> - &quot;examples/ngspice/advanced/monte_carlo.tcl&quot; and &quot;examples/xyce/advanced/monte_carlo.tcl&quot; file</li>
</ul>
<h2 class='ruff'><a name='::Advanced-Monte-Carlo simulation'></a>Monte-Carlo simulation<span class='ruff-uplink'><a href='#top'>Top</a>, <a href='index.html'>Main</a>, <a href='index-docindex.html#'>Index</a></span></h2>
<div style='clear:both;'></div>
<p class='ruff'>This example demonstrates multiple runs of a simple filter circuit and the collection of the resulting statistical distribution of frequency bandwidths. The original circuit source is from the ngspice source distribution. The target filter circuit is:</p>
<p class='ruff'><img src="assets/img/monte_carlo_cir.png" alt="drawing" width="700"/></p>
<p class='ruff'>The filter is a 3rd-order Chebyshev bandpass. The first step is to build the circuit and obtain the magnitude of the transfer characteristic:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
# create top-level circuit
set circuit [Circuit new {Monte-Carlo}]
# add elements to circuit
$circuit add [Vac new 1 n001 0 -ac 1]
$circuit add [R new 1 n002 n001 -r 141]
$circuit add [R new 2 0 out -r 141]
C create c1 1 out 0 -c 1e-9
L create l1 1 out 0 -l 10e-6
C create c2 2 n002 0 -c 1e-9
L create l2 2 n002 0 -l 10e-6
C create c3 3 out n003 -c 250e-12
L create l3 3 n003 n002 -l 40e-6
foreach elem [list c1 l1 c2 l2 c3 l3] {
    $circuit add $elem
}
$circuit add [Ac new -variation oct -n 100 -fstart 250e3 -fstop 10e6]
#set simulator with default 
set simulator [Batch new {batch1}]
# attach simulator object to circuit
$circuit configure -Simulator $simulator

</pre>

</figure><p class='ruff'>Here, we use a different method for creating a class instance: <code>create</code> instead of <code>new</code>. With <code>create</code>, we can directly set a custom object reference name, rather than relying on the automatically generated one by Tcl.</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
C create c1 1 out 0 -c 1e-9
</pre>

</figure><p class='ruff'>Keep in mind that <code>c1</code> is an object reference, not the name of a variable storing the reference. Therefore, it can be used as an object command directly, without the need for a <code>$</code>.</p>
<p class='ruff'>To calculate the magnitude of the transfer function in dB scale from the output voltage phasor, we create a procedure:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
proc calcDbMag {re im} {
    set mag [= {sqrt($re*$re+$im*$im)}]
    set db [= {10*log($mag)}]
    return $db
}

proc calcDbMagVec {vector} {
    foreach value $vector {
        lappend db [calcDbMag [@ $value 0] [@ $value 1]]
    }
    return $db
}
</pre>

</figure><table class='ruff_deflist'>
<tr><td><code>calcDbMagVec</code></td><td>Procedure that apply <code>calcDbMag</code> to list of complex values.</td></tr>
</table>
<p class='ruff'>Run and plot the result:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
# run simulation
$circuit runAndRead
# get data dictionary
set data [$circuit getDataDict]
set trace [calcDbMagVec [dget $data v(out)]]
set freqs [dget $data frequency]
foreach x $freqs y $trace {
    lappend xydata [list [@ $x 0] $y]
}
set chartTransMag [ticklecharts::chart new]
$chartTransMag Xaxis -name &quot;Frequency, Hz&quot; -minorTick {show &quot;True&quot;} -type &quot;log&quot;
$chartTransMag Yaxis -name &quot;Magnitude, dB&quot; -minorTick {show &quot;True&quot;} -type &quot;value&quot;
$chartTransMag SetOptions -title {} -tooltip {} -animation &quot;False&quot; -toolbox {feature {dataZoom {yAxisIndex &quot;none&quot;}}} -grid {left &quot;10%&quot; right &quot;15%&quot;}
$chartTransMag Add &quot;lineSeries&quot; -data $xydata -showAllSymbol &quot;nothing&quot; -symbolSize &quot;1&quot;
set fbasename [file rootname [file tail [info script]]]

$chartTransMag Render -outfile [file normalize [file join html_charts ${fbasename}_typ.html]] -width 1000px
</pre>

</figure><p class='ruff'><img src="assets/img/monte_carlo_typ_mag.png" alt="magnitude plot" /></p>
<p class='ruff'>We define pass bandwidth by edge values -10dB, to find them we use next procedure:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
proc findBW {freqs vals trigVal} {
    # calculate bandwidth of results
    set freqsLen [llength $freqs]
    for {set i 0} {$i&lt;$freqsLen} {incr i} {
        set iVal [@ $vals $i]
        set ip1Val [@ $vals [+ $i 1]]
        if {($iVal&lt;=$trigVal) &amp;&amp; ($ip1Val&gt;=$trigVal)} {
            set freqStart [@ $freqs $i]
        } elseif {($iVal&gt;=$trigVal) &amp;&amp; ($ip1Val&lt;=$trigVal)} {
            set freqEnd [@ $freqs $i]
        }
    }
    set bw [= {$freqEnd-$freqStart}]
    return $bw
}
</pre>

</figure><p class='ruff'>Find bandwidth:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
puts [findBW [lmap freq $freqs {@ $freq 0}] $trace -10]
</pre>

</figure><p class='ruff'>The value is 1.086255 Mhz.</p>
<p class='ruff'>Our goal is to obtain a distribution of bandwidths by varying the filter parameters. To generate random values for these parameters, we use the built-in functions of the <code>math::statistics</code> package from Tcllib. The parameters can be distributed either normally or uniformly. For uniform distribution, we use <code>::math::statistics::random-uniform xmin xmax number</code>; for normal distribution, we use <code>::math::statistics::random-normal mean stdev number</code>. For uniform distribution, we define the following min and max limits for each C and L element:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
set distLimits [dcreate c1 [dcreate min 0.9e-9 max 1.1e-9] l1 [dcreate min 9e-6 max 11e-6] c2 [dcreate min 0.9e-9 max 1.1e-9] l2 [dcreate min 9e-6 max 11e-6] c3 [dcreate min 225e-12 max 275e-12] l3 [dcreate min 36e-6 max 44e-6]]
</pre>

</figure><p class='ruff'>We can specify different numbers of simulations; the more runs we perform, the more accurate the representation becomes. For example, we set the number of simulations to 1,000 runs with 15 intervals for constructing a boxplot:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
# set number of simulations
set mcRuns 100
set numOfIntervals 15
</pre>

</figure><p class='ruff'>Now we ready to run simulations 1000 times and collect results:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
# loop in which we run simulation with uniform distribution
for {set i 0} {$i&lt;$mcRuns} {incr i} {
    #set elements values according to uniform distribution
    foreach elem [list c1 l1 c2 l2 c3 l3] {
        $elem setParamValue [string index $elem 0] [random-uniform {*}[dict values [dget $distLimits $elem]] 1]
    }
    # run simulation
    $circuit runAndRead
    # get data dictionary
    set data [$circuit getDataDict]
    # get results
    if {$i==0} {
        set freqs [dget $data frequency]
        foreach freq $freqs {
            lappend freqRes [@ $freq 0]
        }
    }
    # get vout frequency curve
    lappend traceListUni [calcDbMagVec [dget $data v(out)]]
    # calculate bandwidths values
    lappend bwsUni [findBW $freqRes [@ $traceListUni end] -10]
}
</pre>

</figure><p class='ruff'>To obtain the distribution, we need to determine reasonable limits based on the minimum and maximum of the generated bandwidth values. Using the specified number of intervals (15), we apply the following procedure:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
proc createIntervals {data numOfIntervals} {
    set intervals [::math::statistics::minmax-histogram-limits [tcl::mathfunc::min {*}$data]  [tcl::mathfunc::max {*}$data] $numOfIntervals]
    lappend intervalsStrings [format &quot;&lt;=%.2e&quot; [@ $intervals 0]]
    for {set i 0} {$i&lt;[- [llength $intervals] 1]} {incr i} {
        lappend intervalsStrings [format &quot;%.2e-%.2e&quot; [@ $intervals $i] [@ $intervals [+ $i 1]]]
    }
    return [dcreate intervals $intervals intervalsStr $intervalsStrings]
}
</pre>

</figure><p class='ruff'>Here, we use the dedicated procedure from the statistics package: <code>::math::statistics::minmax-histogram-limits min max number</code>. Additionally, we construct strings in form <code>leftVal-rightVal</code> that represent the intervals on the boxplot chart. We call this procedure and store the results:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
set uniIntervals [createIntervals $bwsUni $numOfIntervals]
</pre>

</figure><p class='ruff'>Finally, to obtain the expected histogram for a uniform distribution, we use the following procedure with the built-in function: <code>::math::statistics::histogram-uniform xmin xmax limits number</code>:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
proc createDist {data intervals} {
    set dist [::math::statistics::histogram $intervals $data]
    return [lrange $dist 0 end-1]
}
</pre>

</figure><p class='ruff'>Call the <code>createDist</code> procedure to calculate the histogram y-axis values, which correspond to the number of bandwidths within each interval:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
set normDist [createDist $bwsNorm [dget $normIntervals intervals]]
</pre>

</figure><p class='ruff'>The same sequence of steps is applied for the normal distribution. We assume that <code>std = (xmax - xmin) / 6</code>, where <code>xmax</code> and <code>xmin</code> are the limits of the uniform distribution.</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
# set parameter's normal distributions limits
set normalLimits [dcreate c1 [dcreate mean 1e-9 std [/ 0.1e-9 3]] l1 [dcreate mean 10e-6 std [/ 1e-6 3]] c2 [dcreate mean 1e-9 std [/ 0.1e-9 3]] l2 [dcreate mean 10e-6 std [/ 1e-6 3]] c3 [dcreate mean 250e-12 std [/ 25e-12 3]] l3 [dcreate mean 40e-6 std [/ 4e-6 3]]]

## loop in which we run simulation with normal distribution
for {set i 0} {$i&lt;$mcRuns} {incr i} {
    #set elements values according to normal distribution
    foreach elem [list c1 l1 c2 l2 c3 l3] {
        $elem setParamValue [string index $elem 0] [random-normal {*}[dict values [dget $normalLimits $elem]] 1]
    }
    # run simulation
    $circuit runAndRead
    # get data dictionary
    set data [$circuit getDataDict]
    # get results
    if {$i==0} {
        set freqs [dget $data frequency]
        foreach freq $freqs {
            lappend freqRes [@ $freq 0]
        }
    }
    # get vout frequency curve
    lappend traceListNorm [calcDbMagVec [dget $data v(out)]]
    # calculate bandwidths values
    lappend bwsNorm [findBW $freqRes [@ $traceListNorm end] -10]
}
# get distribution of bandwidths with normal parameters distribution
set normIntervals [createIntervals $bwsNorm $numOfIntervals]
set normDist [createDist $bwsNorm [dget $normIntervals intervals]]
</pre>

</figure><p class='ruff'>Finally, we plot resulted distributions:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
# plot results with ticklecharts
# chart for uniformly distributed parameters
set chartUni [ticklecharts::chart new]
$chartUni Xaxis -name &quot;Frequency intervals, Hz&quot; -data [list [dget $uniIntervals intervalsStr]] -axisTick {show &quot;True&quot; alignWithLabel &quot;True&quot;} -axisLabel {interval &quot;0&quot; rotate &quot;45&quot; fontSize &quot;8&quot;}
$chartUni Yaxis -name &quot;Bandwidths per interval&quot; -minorTick {show &quot;True&quot;} -type &quot;value&quot;
$chartUni SetOptions -title {} -tooltip {} -animation &quot;False&quot; -toolbox {feature {dataZoom {yAxisIndex &quot;none&quot;}}}
$chartUni Add &quot;barSeries&quot; -data [list $uniDist]
# chart for normally distributed parameters
set chartNorm [ticklecharts::chart new]
$chartNorm Xaxis -name &quot;Frequency intervals, Hz&quot; -data [list [dget $normIntervals intervalsStr]] -axisTick {show &quot;True&quot; alignWithLabel &quot;True&quot;} -axisLabel {interval &quot;0&quot; rotate &quot;45&quot; fontSize &quot;8&quot;}
$chartNorm Yaxis -name &quot;Bandwidths per interval&quot; -minorTick {show &quot;True&quot;} -type &quot;value&quot;
$chartNorm SetOptions -title {} -tooltip {} -animation &quot;False&quot; -toolbox {feature {dataZoom {yAxisIndex &quot;none&quot;}}}
$chartNorm Add &quot;barSeries&quot; -data [list $normDist]
# create multiplot
set layout [ticklecharts::Gridlayout new]
$layout Add $chartNorm -bottom &quot;10%&quot; -height &quot;35%&quot; -width &quot;75%&quot;
$layout Add $chartUni -bottom &quot;60%&quot; -height &quot;35%&quot; -width &quot;75%&quot;

set fbasename [file rootname [file tail [info script]]]
$layout Render -outfile [file normalize [file join html_charts $fbasename.html]] -height 800px -width 1200px
</pre>

</figure><p class='ruff'><img src="assets/img/monte_carlo_dists.png" alt="dists plot" /></p>
<p class='ruff'>We can clearly see the difference between normal and uniform distributions; the intervals are close due to setting the standard deviation of the normal distribution as std = (xmax - xmin) / 6.</p>
<p class='ruff'>We can also take the uniform intervals and calculate the normal distribution values at these intervals:</p>

<figure  class='ruff-snippet ruff-figure'><pre class='ruff'>
# find distribution of normal distributed values in uniform intervals       
set normDistWithUniIntervals [createDist $bwsNorm [dget $uniIntervals intervals]]
set chartCombined [ticklecharts::chart new]
$chartCombined Xaxis -name &quot;Frequency intervals, Hz&quot; -data [list [dget $uniIntervals intervalsStr]] -axisTick {show &quot;True&quot; alignWithLabel &quot;True&quot;} -axisLabel {interval &quot;0&quot; rotate &quot;45&quot; fontSize &quot;8&quot;}
$chartCombined Yaxis -name &quot;Bandwidths per interval&quot; -minorTick {show &quot;True&quot;} -type &quot;value&quot;
$chartCombined SetOptions -title {} -legend  {} -tooltip {} -animation &quot;False&quot; -toolbox {feature {dataZoom {yAxisIndex &quot;none&quot;}}} -grid {left &quot;10%&quot; right &quot;15%&quot;}       
$chartCombined Add &quot;barSeries&quot; -data [list $uniDist] -name &quot;Uniform&quot;
$chartCombined Add &quot;barSeries&quot; -data [list $normDistWithUniIntervals] -name &quot;Normal&quot;
$chartCombined Render -outfile [file normalize [file join html_charts ${fbasename}_combined.html]] -height 800px -width 1200px
</pre>

</figure><p class='ruff'><img src="assets/img/monte_carlo_dists_comb.png" alt="dists comb plot" /></p>
</main><nav class='ruff-nav'><ul ><li class='ruff-toc1'><a style='padding-top:2px;' href='index.html'>Start page</a></li>
<li class='ruff-toc1'><a href='index-docindex.html' accesskey='i'>Index</a></li>
<hr>
<li class='ruff-toc1'><a href='index-List-of-devices.html'>List of devices</a></li>
<li class='ruff-toc1'><a href='index-FAQ.html'>FAQ</a></li>
<li class='ruff-toc1'><a href='index-Tutorials.html'>Tutorials</a></li>
<li class='ruff-toc1'><a href='index-Tips.html'>Tips</a></li>
<li class='ruff-toc1'><a class='ruff-highlight' href='index-Advanced.html'>Advanced</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl.html'>SpiceGenTcl</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Common-BasicDevices.html'>SpiceGenTcl::Common::BasicDevices</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Common-Sources.html'>SpiceGenTcl::Common::Sources</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Ngspice-BasicDevices.html'>SpiceGenTcl::Ngspice::BasicDevices</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Ngspice-Sources.html'>SpiceGenTcl::Ngspice::Sources</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Ngspice-SemiconductorDevices.html'>SpiceGenTcl::Ngspice::SemiconductorDevices</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Ngspice-Analyses.html'>SpiceGenTcl::Ngspice::Analyses</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Ngspice-Simulators.html'>SpiceGenTcl::Ngspice::Simulators</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Xyce-BasicDevices.html'>SpiceGenTcl::Xyce::BasicDevices</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Xyce-Sources.html'>SpiceGenTcl::Xyce::Sources</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Xyce-SemiconductorDevices.html'>SpiceGenTcl::Xyce::SemiconductorDevices</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Xyce-Analyses.html'>SpiceGenTcl::Xyce::Analyses</a></li>
<li class='ruff-toc1'><a href='index-SpiceGenTcl-Xyce-Simulators.html'>SpiceGenTcl::Xyce::Simulators</a></li>
<hr><li class='ruff-toc2'><a href='#::Advanced-Monte-Carlo simulation'>Monte-Carlo simulation</a></li></ul></nav><footer class='ruff-layout-footer ruff-ft'><div style='float: right;'>Document generated by <a href='https://ruff.magicsplat.com'>Ruff!</a></div><div>&copy; George Yashin</div></footer>
</div></body></html>
